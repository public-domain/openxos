	.SBTTL	REALIO - I/O routines using direct physical IO for real mode

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

;This version of the IO module uses the CGA (or EGA in CGA modes) only

	.INCLUD	XOSINC:\XMAC\PCAT.PAR

VRTLIN =!0B3h		;Character to use as vertical line in dump output
KBDSIZE=!50t		;Size of keyboard type-ahead buffer

CBRDATR =!07h		;Color attribute value for normal border character
CIBDATR =!70h		;Color attribute value for inverse border character
CTXTATR =!02h		;Color attribute value for normal text character
CINVATR =!20h		;Color attribute value for inverse text character
CERRATR =!0Ch		;Color attribute value for error message text character

MBRDATR =!07h		;Monochrome attribute value for normal border character
MIBDATR =!70h		;Monochrome attribute value for inverse border character
MTXTATR =!07h		;Monochrome attribute value for normal text character
MINVATR =!70h		;Monochrome attribute value for inverse text character
MERRATR =!0Fh		;Monochrome attribute value for error message text
			;  character

SERDIVISOR=!3t		;Serial baud divisor (3 = 38400, 12t = 9600)

;Subroutine to setup our IO routines (display and keyboard)
;	CALL	setdisp

setdisp:CALL	chkdisp			;Check display type
	MOVW	DI, #xdispbf		;Clear GECKO's saved screen image
	PUSHW	DS
	POPW	ES
	MOVW	CX, #25t*80t
	CLD
	MOVB	AH, txtatr
	MOVB	AL, #' '
	RSTOSW	[DI]
	MOVW	DI, #xdispbf		;Setup our frame
	MOVW	SI, #lblmsg		;Top line
	MOVW	DX, #LBLSIZE
	CALL	mline
	MOVW	DI, #xdispbf+160t*5	;Middle line
	CALL	fline
	MOVW	DI, #xdispbf+160t*24t	;Bottom line
	MOVW	SI, #cprmsg
	MOVW	DX, #CPRSIZE
	CALL	mline
	MOVW	DI, #xdispbf+158t	;Left and right sides
	MOVW	CX, #24t
	MOVB	AH, brdatr
	MOVB	AL, #0B3h
diss8:	STOSW	[DI]
	STOSW	[DI]
	ADDW	DI, #156t
	LOOP	CX, diss8
	MOVB	AL, brdatr		;Get attribute for border
	MOVB	xdispbf+0, #0DAh	;Corners
	MOVB	xdispbf+1, AL
	MOVB	xdispbf+158t, #0BFh
	MOVB	xdispbf+159t, AL
	MOVB	xdispbf+800t, #0C3h
	MOVB	xdispbf+801t, AL
	MOVB	xdispbf+958t, #0B4h
	MOVB	xdispbf+959t, AL
	MOVB	xdispbf+3840t, #0C0h
	MOVB	xdispbf+3841t, AL
	MOVB	xdispbf+3998t, #0D9h
	MOVB	xdispbf+3999t, AL
	MOVW	kbdsta, #kbdnorm	;Store keyboard state dispatch offset
	RET
.PAGE
;Subroutine to display message in frame border
;	c[DX] = Length of message (number of characters)
;	c[DI] = Offset for place to start broader in screen save buffer
;	c[SI] = Offset for message string in code segment (includes
;		  attribute bytes)
;	CALL	mline

mline:	CALL	fline			;Put border line in buffer
	SUBW	DI, #80t.B		;Calculate address for message
	SUBW	DI, DX
	ANDW	DI, #0FFFFFFFEh.B	;Make sure word address
	MOVW	CX, DX
4$:	LODSW	CS:[SI]
	CMPB	AH, #0
	MOVB	AH, brdatr
	JE	6$.S
	SHLB	AH, #4
6$:	STOSW	[DI]			;Put message in buffer
	LOOP	CX, 4$
	RET				;Finished

;Subroutine to store horizontal border line in screen save buffer
;	c[DI] = Offset for place to start broader in screen save buffer
;	CALL	fline

fline:	MOVL	ECX, #80t		;Border is 80 characters
	MOVB	AH, brdatr		;Get attribute byte
	MOVB	AL, #0C4h		;Get character
	RSTOSW	[DI]			;Put border in buffer
	RET				;Thats all
.PAGE
;Subroutine to check for display type - brdatr and curport are set according to
;  if display is monochrome or color

chkdisp:TESTB	dsptype, #01h		;Do we have a color display?
	JE	10$.S			;No
	MOVL	brdatr, #CBRDATR+CIBDATR*100h+CTXTATR*10000h+CERRATR*1000000h
	MOVW	curport, #3D4h
6$:	MOVW	BX, #0B800h		;Get selector for buffer
	JMP	14$.S

;Here if have mono display (MDA, EGA, or VGA)

10$:	MOVL	brdatr, #MBRDATR+MIBDATR*100h+MTXTATR*10000h+MERRATR*1000000h
	MOVW	curport, #3B4h
	MOVW	BX, #0B000h		;Get selector for mono buffer
14$:	MOVB	AL, txtatr		;Initialize text attribute value
	MOVB	attrib, AL
	MOVW	dispseg, BX		;Store display selector
	MOVW	nscladdr+2, BX
	RET
.PAGE
;Subroutine to setup our vectors
;	CALL	setvec

setvec:	PUSHL	EAX
	PUSHW	ES
	PUSHW	#0.B
	POPW	ES
	PUSHF
	CLI				;No interrupts here
	MOVL	EAX, ES:1h*4		;Get current trace trap vector (in
	MOVL	savttv, EAX		;  case someone is tryig to debug us!)
	MOVL	EAX, ES:3h*4		;And get INT3 vector
	MOVL	savi3v, EAX
	POPF
	POPW	ES
	POPL	EAX
	RET

;Subroutine to initialize the user environment when GECKO is started
;	CALL	intusr

intusr:	RET
.PAGE
	.SBTTL	entgecko - Subroutine to set up for entry to GECKO

;Subroutine to set up for entry to GECKO
;	CALL	entgecko

entgecko:
	CLD
	PUSHW	DS			;Save user DS
	PUSHW	#!uregDS
	POPW	DS
	POPW	uregDS			;Save user DS in the right place
	POPW	entrtn			;Save our return address
	POPW	uregEIP	 		;Save user IP
	POPW	uregCS			;Save user CS
	POPW	uregEFR			;And save user flags
	MOVL	uregESP, ESP		;Save user stack pointer
	MOVW	uregSS, SS
	PUSHW	DS			;Set up the GECKO stack pointer
	POPW	SS
	MOVL	ESP, xESP
	MOVL	xESP, #0
	CALL	savusr
	CALL	xscreen			;Set up GECKO's screen
	CALL	xregdmp			;Update register display
	MOVW	DI, #bpttbl		;Point to breakpoint table
	MOVW	CX, #BPTNUM
	CLRW	SI
4$:	CMPB	[DI], #0		;Is this entry in use?
	JE	8$.S			;No - go on
	MOVW	BX, bt_ofs.B[DI]	;Yes - get address
	MOVW	DX, bt_seg.B[DI]
	INCW	BX
	CMPW	BX, uregEIP		;Now stopped at this breakpoint?
	JNE	6$.S			;No
	CMPW	DX, uregCS
	JNE	6$.S			;No
	MOVW	SI, DI			;Yes - remember it
6$:	DECW	BX
	MOVB	AL, bt_ins.B[DI]	;Get instruction
	CALL	putmbyte		;Restore instruction
8$:	ADDW	DI, #bt_ENSZ
	LOOP	CX, 4$
	MOVL	EAX, oradix		;Reset temporary output radix
	MOVL	tradix, EAX
	MOVB	AL, poutmd		;And reset temporary output mode
	MOVB	toutmd, AL
	JMPIW	entrtn			;Return from entgecko
.PAGE
savusr:	CLI				;No interrupts now
	MOVL	uregEAX, EAX		;Save user registers (SS and SP
	MOVL	uregEBX, EBX		;  have already been saved)
	MOVL	uregECX, ECX
	MOVL	uregEDX, EDX
	MOVL	uregEDI, EDI
	MOVL	uregESI, ESI
	MOVL	uregEBP, EBP
	MOVW	uregES, ES
	MOVW	uregFS, FS
	MOVW	uregGS, GS
	CLRW	AX
	MOVW	uregDS+2, AX
	MOVW	uregCS+2, AX
	MOVW	uregSS+2, AX
	MOVW	uregES+2, AX
	MOVW	uregFS+2, AX
	MOVW	uregGS+2, AX
	INB	21h			;Get current interrupt mask
	MOVB	intmask, AL		;Save it
	MOVB	AL, #0FFh		;Disable all interrupts
	OUTB	21h
	PUSHW	#0.B
	POPW	ES
	MOVL	EAX, savttv		;Restore user's trace trap vector
	MOVL	ES:1h*4, EAX
	MOVL	EAX, savi3v		;And his INT3 vector
	MOVL	ES:3h*4, EAX
	MOVB	kbdcnt, #0		;Initialize the keyboard type-ahead
	MOVL	kbdput, #kbdbfr		;  buffer
	MOVL	kbdtak, #kbdbfr
	MOVB	stpflg, #0		;Make sure output not stopped
retio02:RET				;Finished
.PAGE
;Subroutine to display GECKO's screen
;	CALL	xscreen

xscreen:CMPB	serterm, #0		;Using console?
	JNE	retio02			;No - nothing needed here
	CALL	chkdisp			;Get current display type (mono
	PUSHW	DS			;  or color)
	POPW	ES			;Save user's screen
	MOVW	DI, #udispbf
	MOVW	FS, dispseg
	CLRW	SI
	MOVW	CX, #1024t*2
	CLD
	RMOVSW	[DI], FS:[SI]
	MOVW	DX, curport
	MOVB	AL, #10t		;Make sure have block cursor
	OUTB	[DX]
	JMP	$+2.S
	MOVB	AL, #0
	INCW	DX
	OUTB	[DX]
	JMP	$+2.S
	MOVB	AL, #11t
	DECW	DX
	OUTB	[DX]
	JMP	$+2.S
	MOVB	AL, #0Dh
	INCW	DX
	OUTB	[DX]
	JMP	$+2.S
	DECW	DX			;Setup GECKO's cursor
	MOVB	AL, #14t		;Set high order byte
	OUTB	[DX]
	JMP	$+2.S
	MOVB	AL, xcursor+1
	INCW	DX
	OUTB	[DX]
	JMP	$+2.S
	MOVB	AL, #15t		;Set low order byte
	DECW	DX
	OUTB	[DX]
	JMP	$+2.S
	MOVB	AL, xcursor+0
	INCW	DX
	OUTB	[DX]
	MOVW	ES, dispseg		;Set up GECKO's screen
	CLRW	DI
	MOVW	SI, #xdispbf
	MOVW	CX, #1024t*2
	RMOVSW	[DI], [SI]
	MOVW	DX, curport		;Set to display GECKO screen
	MOVB	AL, #0Ch
	OUTB	[DX]
	JMP	$+2.S
	INCW	DX
	MOVB	AL, #0
	OUTB	[DX]
	JMP	$+2.S
	DECW	DX
	MOVB	AL, #0Dh
	OUTB	[DX]
	JMP	$+2.S
	INCW	DX
	MOVB	AL, #0
	OUTB	[DX]
	JMP	$+2.S
	ADDW	DX, #P_EGACSTS1-P_EGACCRTDATA.B ;Get port for status 1 register
	INB	[DX]			;Read input status 1 register to reset
	JMP	$+2.S			;  attribute port to the index register
	MOVB	DL, #P_EGAATTRIB&0FFh	;Get attribute controller port
	MOVB	AL, #20h
	OUTB	[DX]
	MOVB	screen, #1		;Remember displaying GECKO's screen
2$:	RET				;Thats all
.PAGE
	.SBTTL	rstusr - Subroutine to restore user state

;Subroutine to restore user state
;	CALL	rstusr

rstusr:	CMPB	screen, #0		;Need to switch screens?
	JE	rstus2.S		;No
	CALL	uscreen			;Yes - restore user screen
rstus2:	PUSHW	#0.B
	POPW	ES
	MOVL	EAX, ES:1h*4		;Save trace trap vector (in case
	MOVL	savttv, EAX		;  someone is trying to debug us!)
	MOVL	EAX, ES:3h*4		;And INT3 vector
	MOVL	savi3v, EAX
	MOVW	ES:1h*4+0, #debugtrapr	;Set our trace trap vector
	MOVW	ES:1h*4+2, CS
	MOVW	ES:3h*4+0, #bptent	;Set INT3 vector
	MOVW	ES:3h*4+2, CS
	MOVB	AL, intmask
	OUTB	21h
	MOVW	ES, uregES		;Restore user registers
	MOVW	FS, uregFS
	MOVW	GS, uregGS
	MOVL	EDI, uregEDI
	MOVL	ESI, uregESI
	MOVL	EBP, uregEBP
	MOVL	EDX, uregEDX
	MOVL	ECX, uregECX
	MOVL	EBX, uregEBX
	MOVL	EAX, uregEAX
	STI
retio04:RET				;Finished
.PAGE
;Subroutine to save GECKO screen and display user screen
;	CALL	uscreen

uscreen:CMPB	serterm, #0		;Using console?
	JNE	retio04.S		;No - nothing to do here
	PUSHW	DS			;Yes - save GECKO's screen
	POPW	ES
	MOVW	DI, #xdispbf
	MOVW	FS, dispseg
	CLRW	SI
	MOVW	CX, #1024t*2
	CLD
	RMOVSW	[DI], FS:[SI]
	MOVW	DX, curport		;Save GECKO's cursor position
	MOVB	AL, #14t		;Get high order byte
	OUTB	[DX]
	JMP	$+2.S
	INCW	DX
	INB	[DX]
	JMP	$+2.S
	MOVB	AH, AL
	MOVB	AL, #15t		;Get low order byte
	DECW	DX
	OUTB	[DX]
	JMP	$+2.S
	INCW	DX
	INB	[DX]
	JMP	$+2.S
	MOVW	xcursor, AX		;Store GECKO cursor location

;CODE HERE TO RESTORE USER'S CURSOR TYPE AND POSITION

	MOVW	ES, dispseg		;Set up user's screen
	CLRW	DI
	MOVW	SI, #udispbf
	MOVW	CX, #1024t*2
	RMOVSW	[DI], [SI]

;;;;;;	MOVW	DX, curport		;Set to display user screen
;;;;;;	MOVB	AL, #12t
;;;;;;	OUTB	[DX]
;;;;;;	JMP	$+2.S
;;;;;;	INCW	DX
;;;;;;	MOVB	AL, GS:12t.B[BX]
;;;;;;	OUTB	[DX]
;;;;;;	JMP	$+2.S
;;;;;;	DECW	DX
;;;;;;	MOVB	AL, #13t
;;;;;;	OUTB	[DX]
;;;;;;	JMP	$+2.S
;;;;;;	INCW	DX
;;;;;;	MOVB	AL, GS:13t.B[BX]
;;;;;;	OUTB	[DX]
	MOVB	screen, #0		;Remember displaying user's screen
	RET				;Thats all
.PAGE
;Here for exit command

goexit:	INCB	CS:quitflg		;Indicate want to quit
	CMPB	screen, #0		;Need to restore user screen?
	JE	exit2.S			;No
	CALL	uscreen			;Yes
	MOVB	AL, intmask		;Restore interrupt enables
	OUTB	21h
exit2::	MOVW	AX, #4C00h		;Exit to MS-DOS
	INT	21h

;Here to set or clear a watchpoint
;	c(AL)     = Trap number (0 to 3)
;	c(AH)     = Trap type
;	c{DX:EBX} = Address
;	CALL	wptsetclr
;	C:set = Error
;	C:clr = Normal

wptsetclr:
	STC
	RET
.PAGE
	.SBTTL	swclient - Routine to switch to/from serial client

;Here on SC command to switch to/from serial client

swclient:
	PUSHL	#0FFFFFFFE.B		;Save value for serterm to indicate
	JMP	2$.S			;  using serial client

	.SBTTL	swterm - Routine to switch to/from serial terminal

;Here on ST command to switch to/from serial terminal

swterm:	PUSHL	#0FFFFFFFF.B		;Save value for serterm to indicate
					;  using serial terminal
2$:	CMPB	screen, #0		;Currently displaying GECKO's screen?
	JE	6$.S			;No
	CALL	uscreen			;Yes - restore user's screen
6$:	POPL	EAX
	CMPB	serterm, #0		;Currently using console?
	JNE	8$.S			;No
	MOVB	serterm, AL		;Yes - switch to serial terminal or
					;  client
	CMPB	serset, #0		;Is the serial port set up?
	JE	setupterm		;No - set it up now
	RET				;Yes - finished

;Here if switching to console

8$:	MOVB	serterm, #0
	JMP	xscreen
.PAGE
;Subroutine to get memory segment type (this routine assumes that the segment
;  has already been accessed by calling getmbyte, getmword, or getmlong to
;  verify that the selector is valid)
;	c[DX] = Segment selector
;	CALL	getmtype
;	c(AL) = Segment type
;		   2t = 32 bit data segment
;		   5t = 32 bit code segment
;		  10t = 16 bit data segment
;		  13t = 16 bit code segment

getmtype:
	MOVB	AL, #10t
	CLC
	RET
.PAGE
;Subroutine to get byte from memory
;	c[DX]  = Segment selector
;	c{EBX} = Segment offset
;	CALL	getmbyte
;	c{EAX} = Value (byte zero extended to 32 bits)

getmbyte:
	TESTL	EBX, #0FFFF0000h
	JNE	memerr.S
	PUSHW	ES
	MOVW	ES, DX
	MOVZWL	EAX, ES:[EBX]
	POPW	ES
	CLC
	RET

;Subroutine to get word from memory
;	c[DX]  = Segment selector
;	c{EBX} = Segment offset
;	CALL	getmword
;	c{EAX} = Value (word zero extended to 32 bits)

getmword:
	TESTL	EBX, #0FFFF0000h
	JNE	memerr.S
	PUSHW	ES
	MOVW	ES, DX
	MOVZWL	EAX, ES:[EBX]
	POPW	ES
	CLC
	RET

;Subroutine to get long from memory
;	c[DX]  = Segment selector
;	c{EBX} = Segment offset
;	CALL	getmword
;	c{EAX} = Value

getmlong:
	TESTL	EBX, #0FFFF0000h
	JNE	memerr.S
	PUSHW	ES
	MOVW	ES, DX
	MOVL	EAX, ES:[EBX]
	POPW	ES
	CLC
	RET

memerr:	CLRL	EAX
	STC
	RET

;Subroutine to store byte to memory
;	c(AL)  = Value
;	c[DX]  = Segment selector
;	c{EBX} = Segment offset
;	CALL	putmbyte

putmbyte:
	TESTL	EBX, #0FFFF0000h
	JNE	memerr.S
	PUSHW	ES
	MOVW	ES, DX
	MOVB	ES:[EBX], AL
	POPW	ES
	CLC
	RET

;Subroutine to store word to memory
;	c[AX]  = Value
;	c[DX]  = Segment selector
;	c{EBX} = Segment offset
;	CALL	putmbyte

putmword:
	TESTL	EBX, #0FFFF0000h
	JNE	memerr.S
	PUSHW	ES
	MOVW	ES, DX
	MOVW	ES:[EBX], AX
	POPW	ES
	CLC
	RET

;Subroutine to store long to memory
;	c{EAX} = Value
;	c[DX]  = Segment selector
;	c{EBX} = Segment offset
;	CALL	putmbyte

putmlong:
	TESTL	EBX, #0FFFF0000h
	JNE	memerr.S
	PUSHW	ES
	MOVW	ES, DX
	MOVL	ES:[EBX], EAX
	POPW	ES
	CLC
	RET
.PAGE
;Subroutine to setup serial port for use with serial terminal
;	CALL	setupterm

setupterm:
	MOVW	DX, #P_COM1BASE+P_COMLINECON ;Point to line control register
	MOVB	AL, #0			;Make sure interrupt enable register
	OUTB	[DX]			;  is available
	JMP	$+2.S				 ;Point to interrupt enable
	ADDW	DX, #P_COMINTENB-P_COMLINECON.B ;  register
	MOVB	AL, #0			;Disable all interrupts
	OUTB	[DX]
	JMP	$+2.S
	ADDW	DX, #P_COMMODMCON-P_COMINTENB ;Point to modem control register
	MOVB	AL, #03h		;Enable DTR and RTS, disable interrupts
	OUTB	[DX]
	JMP	$+2.S				  ;Point to line control
	ADDW	DX, #P_COMLINECON-P_COMMODMCON.B ;  register
	MOVB	AL, #83h		;8 bits, 1 stop bit, no parity, enable
	OUTB	[DX]			;  access to the divisor latch register
	JMP	$+2.S
	ADDW	DX, #P_COMBRLSB-P_COMLINECON.B ;Point to divisor LSB register
	MOVB	AL, #SERDIVISOR		;Get divisor value
	OUTB	[DX]			;Output LSB
	JMP	$+2.S
	MOVB	AL, #0			;Get high byte
	INCW	DX			;Point to divisor MSB register
	OUTB	[DX]			;Output MSB
	JMP	$+2.S
	INCW	DX			;Point to the line control register
	INCW	DX			;  again
	MOVB	AL, #03h		;Enable access to the data registers now
	OUTB	[DX]
	RET				;All done
.PAGE
;Subroutine to echo ESC to the terminal
;	CALL	echoesc

echoesc:MOVB	AL, #0E8h		;Assume should echo as phi
	CMPB	serterm, #0		;Using serial terminal?
	JE	outchx.S		;No
	MOVB	AL, #'$'		;Yes - echo as $
					;Fall into outchx

;Internal subroutine to output character to scrolling region
;	c(AL) = Character to output
;	CALL	outchx

outchx:	CALL	chkchx			;Check for keyboard character
	CMPB	stpflg, #0		;Want to stop output?
	JNE	outchx.S		;Yes - wait
	MOVB	nohalt, #1		;No - indicate should not stop now
	PUSHW	ES			;Save registers
	PUSHL	EBX
	PUSHL	EDX
	CMPB	AL, #' '		;Printing character?
	JNC	30$			;Yes
	CMPB	AL, #CR			;No - return?
	JNE	4$.S			;No
	MOVB	horpsn, #0		;Yes - reset position
	JMP	8$.S

4$:	CMPB	AL, #LF			;Line feed?
	JNE	6$.S			;No
	CMPB	serterm, #-1		;Yes - serial terminal
	JE	32$			;Yes
	JMP	scrollup		;No

;Here if not line feed

6$:	CMPB	AL, #BS			;Backspace?
	JNE	12$.S			;No
	CMPB	horpsn, #0		;Yes - at beginning of line?
	JE	10$.S			;Yes
	DECB	horpsn			;No - reduce position
8$:	CMPB	serterm, #-1		;Using serial terminal?
	JNE	11$.S			;No - go display updated cursor
	JMP	32$			;Yes - just output the character

10$:	CMPB	serterm, #-1		;Using serial terminal?
	JE	15$.S			;Yes - do nothing
	SUBW	verpsn, #80t.B		;No - backup to end of previous line
	DECB	curlin
	MOVB	horpsn, #77t
11$:	JMP	dspcur

;Here if not backspace

12$:	CMPB	AL, #HT			;Horizontal tab?
	JNE	16$.S			;No
14$:	MOVB	AL, #' '		;Yes - output space
	INCB	horpsn
	CALL	onscrn
	TESTB	horpsn, #7		;At tab stop yet?
	JNE	14$.S			;No - contin;ue
15$:	JMP	disdon			;Yes - finished

;Here if not horizontal tab

16$:	CMPB	AL, #ERR		;Change color for error text?
	JNE	18$.S			;No
	MOVB	AH, erratr		;Yes
	JMP	20$.S

18$:	CMPB	AL, #TXT		;Change color for normal text?
	JNE	22$.S			;No
	MOVB	AH, txtatr
20$:	MOVB	attrib, AH
	JMP	disdon

22$:	CMPB	AL, #INV		;Change to inverse video?
	JNE	24$.S			;No
	MOVB	AH, invatr
	JMP	20$.S

24$:	CMPB	AL, #CLR		;Clear line?
	JNE	30$.S			;No
	CMPB	serterm, #-1		;Using serial terminal?
	JE	25$.S			;Yes - go handle that
	MOVB	horpsn, #0		;Yes
	PUSHL	EDI
	PUSHW	ES
	CMPB	screen, #0		;Displaying GECKO's screen?
	JE	26$.S			;No
	LESW	DI, sclladdr		;Yes - scroll the real display
	JMP	28$.S

;Here to clear line for serial terminal

25$:	MOVB	AL, #CR			;Move to beginning of line
	CALL	tosert
	MOVB	AL, #ESC		;Clear the line
	CALL	tosert
	MOVB	AL, #'['
	CALL	tosert
	MOVB	AL, #'K
	CALL	tosert
	JMP	disdon

;Here if not displaying GECKO's screen

26$:	LESW	DI, xscrlbf		;Scroll the saved display
28$:	ADDW	DI, verpsn
	ADDW	DI, verpsn
	ADDW	DI, #2.B
	MOVB	AH, txtatr
	MOVB	AL, #' '
	MOVL	ECX, #78t
	CLD
	RSTOSW	[DI]
	POPW	ES
	POPL	EDI
	JMP	dspcur

;Here with printing character

30$:	INCB	horpsn			;Bump horizontal position
32$:	CALL	onscrn			;Put character on screen

;Here to update cursor position

dspcur:	CMPB	serterm, #-1		;Using serial terminal?
	JE	34$.S			;Yes - finished
	CMPB	screen, #0		;Displaying GECKO's screen?
34$:	JE	disdon			;No - finished
	MOVW	DX, curport		;Yes
	MOVW	BX, horpsn		;Calculate character offset on screen
	ADDW	BX, verpsn
	ADDW	BX, #80t*6+1
	MOVB	AL, #15t		;Point to cursor register in CRTC
	OUTB	[DX]
	MOVB	AL, BL
	INCW	DX
	OUTB	[DX]
	MOVB	AL, #14t
	DECW	DX
	OUTB	[DX]
	MOVB	AL, BH
	INCW	DX
	OUTB	[DX]
	JMP	disdon			;Thats all
.PAGE
;Here to scroll screen up one line

scrollup:
	CMPB	nonscrl, #0		;Output to nonscrolling region?
	JNE	2$.S			;Yes
	MOVB	AL, curlin		;No - on last line now?
	INCB	AL
	CMPB	scllsiz, AL
	JBE	4$.S			;Yes
	MOVB	curlin, AL		;No - just move down a line
2$:	ADDW	verpsn, #80t.B
	JMP	dspcur.S		;And go update cursor

;Here if now on last line of scrolling region

4$:	PUSHL	ESI
	PUSHL	EDI
	PUSHL	ECX
	CMPB	screen, #0		;Displaying GECKO's screen?
	JE	6$.S			;No
	LESW	DI, sclladdr		;Yes - scroll the real display
	JMP	8$.S

6$:	LESW	DI, xscrlbf		;Scroll the saved display
8$:	MOVZBW	CX, scllsiz		;Get size of scrolling area (lines)
	DECW	CX			;Minus one
	IMULW	CX, #80t.B		;Change to number of words
	LEAW	SI, 160t[DI]
	CLD
	RMOVSW	[DI], ES:[SI]		;Move screen up one line
	MOVB	AH, brdatr
	MOVB	AL, #0B3h
	STOSW	[DI]
	MOVB	AH, txtatr		;Fill last line with spaces
	MOVB	AL, #' '

	MOVL	ECX, #39t*2
	RSTOSW	[DI]
	MOVB	AH, brdatr
	MOVB	AL, #0B3h
	STOSW	[DI]
	POPL	ECX
	POPL	EDI
	POPL	ESI
disdon:	POPL	EDX
	POPL	EBX
	POPW	ES
	MOVB	nohalt, #0		;Allow stopping now
	CMPB	hltflg, #0		;Should we stop now?
	JE	disdo2.S
	MOVB	hltflg, #0		;Yes - only once!
	JMP	ctrlc2

disdo2:	RET
.PAGE
;Subroutine to place character on screen
;	c(AL) = Character
;	CALL	onscrn

onscrn:	CMPB	horpsn, #78t		;Too far right?
	JBE	2$.S			;No
	PUSHL	EAX			;Yes - save character
	CALL	outcrl			;Go to next line
	POPL	EAX
	INCB	horpsn
2$:	CMPB	nonscrl, #0		;Write to non-scrolling region?
	JE	6$.S			;No
	CMPB	serterm, #0		;Yes - using serial terminal?
	JNE	16$.S			;Yes - ignore this!
	CMPB	screen, #0		;No
	JE	4$.S
	LESW	BX, nscladdr
	JMP	14$.S

4$:	LESW	BX, xnsclbf
	JMP	14$.S

6$:	TESTB	prtflg, #1		;Should we output to the printer too?
	JE	10$.S			;No
	PUSHL	EAX			;Yes

;CODE GOES HERE TO OUTPUT TO PRINTER!

	POPL	EAX
10$:	CMPB	serterm, #0		;Using serial terminal?
	JNE	tosert.S		;Yes
	CMPB	screen, #0		;No
	JE	12$.S
	LESW	BX, sclladdr
	JMP	14$.S

12$:	LESW	BX, xscrlbf
14$:	MOVB	AH, attrib
	PUSHL	EAX
	MOVW	AX, horpsn
	ADDW	AX, verpsn
	ADDW	AX, AX
	ADDW	BX, AX
	POPL	EAX
	MOVW	ES:[BX], AX
16$:	RET

;Here it doing output to serial terminal

tosert:	PUSHL	EDX
	PUSHL	EAX
	MOVL	EDX, #P_COM1BASE+P_COMLINESTS ;Point to status register
22$:	INB	[DX]			;Get status
	TESTB	AL, #20h		;Wait until output is done
	JE	22$.S
	ADDL	EDX, #P_COMMODMSTS-P_COMLINESTS.B
24$:	INB	[DX]
	TESTB	AL, #20h
	JE	24$.S
	ADDL	EDX, #P_COMXDATA-P_COMMODMSTS.B
	POPL	EAX
	OUTB	[DX]			;Output character
	POPL	EDX
	RET
.PAGE
;Define bits for the keyboard state word keysts

KS$LALT  =!0200h	;Left alt key state
KS$RALT  =!0100h	;Right alt key state
KS$LCTRL =!0020h	;Left control key state
KS$RCTRL =!0010h	;Right control key state
KS$LSHFT =!0008h	;Left shift key state
KS$RSHFT =!0004h	;Right shift key state

;Subroutine to get input character from terminal
;	CALL	inpchx
;	c(AL) = Character

inpchx:	CMPB	kbdcnt, #0		;Anything in the keyboard buffer?
	JNE	8$			;Yes
2$:	CALL	getkchr			;No - get character from keyboard
	JC	2$.S
	CLC
	RET

;Here with buffered character

8$:	PUSHL	EBX
	MOVW	BX, kbdtak		;Yes - get taker pointer
	MOVB	AL, [BX]		;Get character
	INCW	BX			;Bump pointer
	CMPW	BX, #kbdend		;At end of buffer?
	JB	inpch2			;No
	MOVW	BX, #kbdbfr		;Yes - reset pointer
inpch2:	MOVW	kbdtak, BX		;Store pointer
	POPL	EBX
	DECB	kbdcnt			;Reduce count
	RET				;Return with character
.PAGE
;Subroutine to check for type-ahead

chkchx:	PUSHL	EAX
	CALL	getkchr			;See if have character
	JC	6$.S			;Nope
	CMPB	kbdcnt, #KBDSIZE-1	;Yes - too many characters?
	JAE	6$.S			;Yes - forget this one!
	INCB	kbdcnt			;No - bump count
	PUSHL	EBX
	MOVW	BX, kbdput		;Get putter pointer
	MOVB	[BX], AL		;Store character
	INCW	BX			;Bump pointer
	CMPW	BX, #kbdend		;At end of buffer
	JB	4$.S			;No
	MOVW	BX, #kbdbfr		;Yes - reset pointer
4$:	MOVW	kbdput, BX
	POPL	EBX
6$:	POPL	EAX
	RET
.PAGE
;Subroutine to get character from keyboard

getkchr:CMPB	serterm, #0		;Using serial terminal?
	JE	6$.S			;No
	PUSHW	DX			;Yes
	MOVW	DX, #P_COM1BASE+P_COMLINESTS ;Point to the line status register
	INB	[DX]			;Get status
	RCRB	AL, #1			;Have input character?
	JC	4$.S			;Yes
	POPW	DX			;No
2$:	STC
	RET

;Here with keyboard character from the serial port

4$:	ADDW	DX, #P_COMRDATA-P_COMLINESTS.B ;Point to data register
	INB	[DX]			;Get input character
	ANDB	AL, #7Fh		;Only use 7 bits
	POPW	DX			;And return with it
	CLC
	RET

;Here if using console keyboard

6$:	INB	P_KEYSTS		;Have anything from the keyboard?
	ANDB	AL, #1
	JE	2$.S			;No
	PUSHW	ES			;Yes
	PUSHW	BX
	PUSHW	SI
	INB	P_KEYDATA		;Get keyboard scan code
	MOVB	AH, #0
	MOVW	BX, AX
	CMPB	AL, #0E0h		;Yes - is this a special prefix?
	JE	8$.S			;Yes
	CMPB	AL, #0E1h		;Maybe
	JNE	10$.S			;No
	MOVW	kbdsta, #kbdhvE1	;Yes - advance state
	JMP	kbdin6.S		;Otherwise ignore this key

;Here if have E0 from keyboard

8$:	MOVW	kbdsta, #kbdhvE0	;Advance state
kbdin6:	STC
	JMP	22$

10$:	JMPIW	kbdsta			;Dispatch on current keyboard state

;Here if have normal character from keyboard

kbdnorm:MOVW	BX, #keytbl
	JMP	12$.S

;Here if have character after E0 from keyboard

kbdhvE0:MOVW	BX, #keytblE0		;No - get offset of table to use
	MOVW	kbdsta, #kbdnorm	;Reset keyboard mode
12$:	ORB	AL, AL			;Break code?
	JNS	14$.S			;No
	ANDB	AL, #7Fh		;Yes
	CMPB	AL, #58h		;Is value in range?
	JA	20$.S			;No - ignore it!
	ADDW	BX, AX
	MOVB	AL, CS:[BX]		;Get corresponding index
	ORB	AL, AL			;Special key?
	JNS	20$.S			;No - ignore normal break code
	MOVW	BX, AX
	JMPIW	CS:bkytbl-80[BX]	;Yes - dispatch on the special code

;Here for normal character

14$:	CMPB	AL, #58h		;Is value in range?
	JA	20$.S			;No - ignore it!
	ADDW	BX, AX
	MOVB	AL, CS:[BX]		;Get corresponding index
	ORB	AL, AL			;Is this a normal ASCII code?
	JS	24$.S			;No
kbdcom:	MOVB	BL, keysts		;Yes - get shift state
	MOVB	BH, #0
	MOVW	SI, CS:codtbl[BX]	;Get current keyboard table
	ADDW	SI, AX
	MOVB	AL, CS:[SI]		;Get code value
	ORB	AL, AL
	JNE	22$.S
20$:	STC
22$:	POPW	SI
	POPW	BX
	POPW	ES
	RET

;Here with non-ASCII keyboard code

24$:	JMPIL	CS:mkytbl-80[EAX]	;Dispatch on the special code
.PAGE
;Here if have character after E1 from keyboard

kbdhvE1:CMPB	AL, #1Dh		;Make of control key?
	JE	6$.S
	CMPB	AL, #9Dh		;Control break?
	JNE	4$.S			;No - ignore this!
	MOVW	kbdsta, #4$		;Yes - advance state so will ignore
2$:	JMP	kbdin6			;  next character

;Here to reset state and ignore character

4$:	MOVW	kbdsta, #kbdnorm
	JMP	2$.S

;Here if have 1D following E1 from keyboard

6$:	MOVW	kbdsta, #pausmak
	JMP	2$.S

;Here if have character after E1-1D sequence from keyboard

pausmak:CMPB	AL, #45h		;Is this the right code?
	JNE	4$.S			;No - ignore it
	MOVB	AL, #5Eh		;Yes - index for pause
	MOVW	kbdsta, #kbdnorm	;Reset keyboard mode
	JMP	kbdcom.S		;Continue
.PAGE
;Special key make code dispatch table

mkytbl:	.LONG	kbdin6		;SK_NULL  = 80h - Unused code
	.LONG	mlshft		;SK_LSHFT = 84h - Left shift key
	.LONG	mrshft		;SK_RSHFT = 88h - Right shift key
	.LONG	mlctrl		;SK_LCTRL = 8Ch - Left control key
	.LONG	mrctrl		;SK_RCTRL = 90h - Right control key
	.LONG	mlalt		;SK_LALT  = 94h - Left alt key
	.LONG	mralt		;SK_RALT  = 98h = Right alt key
	.LONG	ctrls		;SK_CTRLS = 9Ch - Ctrl-S
	.LONG	ctrlq		;SK_CTRLQ = A0h - Ctrl-Q
	.LONG	ctrlc		;SK_CTRLC = A4h - Ctrl-C
	.LONG	delkey1		;SK_DEL1  = A8h - DEL key
	.LONG	delkey2		;SK_DEL2  = ACh - Keypad DEL key

codtbl:	.LONG	keynrm		;0000 - No shift or control keys pressed
	.LONG	keyshf		;0001 - Right shift key pressed
	.LONG	keyshf		;0010 - Left shift key pressed
	.LONG	keyshf		;0011 - Both shift keys pressed
	.LONG	keyctl		;0100 - Right control key pressed
	.LONG	keyctl		;0101
	.LONG	keyctl		;0110
	.LONG	keyctl		;0111
	.LONG	keyctl		;1000 - Left control key pressed
	.LONG	keyctl		;1001
	.LONG	keyctl		;1010
	.LONG	keyctl		;1011
	.LONG	keyctl		;1100 - Both control keys pressed
	.LONG	keyctl		;1101
	.LONG	keyctl		;1110
	.LONG	keyctl		;1111

;Special key break code dispatch table

bkytbl:	.LONG	kbdin6		;SK_NULL  = 80h - Unused key
	.LONG	blshft		;SK_LSHFT = 84h - Left shift key
	.LONG	brshft		;SK_RSHFT = 88h - Right shift key
	.LONG	blctrl		;SK_LCTRL = 8Ch - Left control key
	.LONG	brctrl		;SK_RCTRL = 90h - Right control key
	.LONG	blalt		;SK_LALT  = 94h - Left alt key
	.LONG	bralt		;SK_RALT  = 98h - Right alt key
	.LONG	kbdin6		;SK_CTRLS = 9Ch - Ctrl-S
	.LONG	kbdin6		;SK_CTRLQ = A0h - Ctrl-Q
	.LONG	kbdin6		;SK_CTRLC = A4h - Ctrl-C
	.LONG	kbdin6		;SK_DEL1  = A8h - DEL key
	.LONG	kbdin6		;SK_DEL2  = ACh - Keypad DEL key

;Here for make of left shift key

mlshft:	ORB	keysts, #KS$LSHFT
	JMP	6$.S

;Here for break of left shift key

blshft:	ANDB	keysts, #~KS$LSHFT
	JMP	6$.S

;Here for make of right shift key

mrshft:	ORB	keysts, #KS$RSHFT
	JMP	6$.S

;Here for break of right shift key

brshft:	ANDB	keysts, #~KS$RSHFT
	JMP	6$.S

;Here for make of left control key

mlctrl:	ORB	keysts, #KS$LCTRL
	JMP	6$.S

;Here for break of left control key

blctrl:	ANDB	keysts, #~KS$LCTRL
	JMP	6$.S

;Here for make of right control key

mrctrl:	ORB	keysts, #KS$RCTRL
	JMP	6$.S

;Here for break of right control key

brctrl:	ANDB	keysts, #~KS$RCTRL
	JMP	6$.S

;Here for make of left alt key

mlalt:	ORB	keysts+1, #KS$LALT>8
	JMP	6$.S

;Here for break of left alt key

blalt:	ANDB	keysts+1, #~{KS$LALT>8}
	JMP	6$.S

;Here for make of right alt key

mralt:	ORB	keysts+1, #KS$RALT>8
	JMP	6$.S

;Here for break of right alt key

bralt:	ANDB	keysts+1, #~{KS$RALT>8}
	JMP	6$.S

;Here for make of ctrl-C key

ctrlc:	CMPB	nohalt, #0		;Can we stop now?
	JE	ctrlc2			;Yes
	MOVB	hltflg, #1		;No - stop later
6$:	JMP	kbdin6

ctrlc2:	XORL	EAX, EAX
	MOVB	kbdcnt, AL		;Initialize the keyboard type-ahead
	MOVW	kbdput, #kbdbfr		;  buffer
	MOVW	kbdtak, #kbdbfr
	MOVL	EBX, #cncech		;Echo the ctrl-C
	CALL	outstrc
	MOVB	AL, #20h
	OUTB	20h
	JMP	restart

;Here for make of ctrl-S key

ctrls:	MOVB	stpflg, #1		;Indicate should stop output
	JMP	6$.S

;Here for make of ctrl-Q key

ctrlq:	MOVB	stpflg, #0		;Indicate output is OK
	JMP	6$.S
.PAGE
;Here for make of the DEL key

delkey1:MOVB	AL, #48h
	JMP	4$.S

;Here for make of the keypad DEL key

delkey2:MOVB	AL, #58h
4$:	TESTB	keysts+1, #{KS$LALT|KS$RALT}>8 ;Either alt key pressed?
	JE	6$.S			;No - just normal DEL
	TESTB	keysts, #KS$LCTRL|KS$RCTRL ;Either control key pressed?
6$:	JE	kbdcom			;No - just normal DEL
	JMP	goexit			;Yes - exit!
.PAGE
debugtrapr:
	CALL	entgecko
	MOVL	EAX, #4000h	
	JMP	debugtrap
.PAGE
;Subroutine to display registers when using the serial client

cregdmp:MOVW	CX, #16t
	MOVW	BX, #scrtbl
	MOVL	EDX, #uregbase
2$:	CMPB	allregs, #0
	JNE	6$.S
	MOVL	EAX, [EDX]
	CMPL	EAX, uregvalue-uregbase[EDX]
	JE	10$.S
6$:	MOVB	AL, CS:[BX]
	CALL	tosert
	CMPB	AL, #5
	JE	8$.S
	MOVB	AL, 3.B[EDX]
	CALL	tosert
	MOVB	AL, 2.B[EDX]
	CALL	tosert
8$:	MOVB	AL, 1.B[EDX]
	CALL	tosert
	MOVB	AL, [EDX]
	CALL	tosert
	MOVB	AL, CS:1.B[BX]
	CALL	tosert
10$:	MOVL	EAX, [EDX]
	MOVL	uregvalue-uregbase[EDX], EAX
	ADDW	BX, #2t.B
	ADDW	DX, #4t.B
	LOOP	CX, 2$
	RET
.PAGE
	.SBTTL	keytbl - Master keyboard translation tables

;Define symbols for indexes for special keys

SK_NULL  =!080h		;Unused code
SK_LSHFT =!084h		;Left shift key
SK_RSHFT =!088h		;Right shift key
SK_LCTRL =!08Ch		;Left control key
SK_RCTRL =!090h		;Right control key
SK_LALT  =!094h		;Left alt key
SK_RALT  =!098h		;Right alt key
SK_CTRLS =!09Ch		;Ctrl-S
SK_CTRLQ =!0A0h		;Ctrl-Q
SK_CTRLC =!0A4h		;Ctrl-C or ctrl-BREAK
SK_DEL1  =!0A8h		;DEL key
SK_DEL2  =!0ACh		;Keypad DEL key

;Keyboard translation table.  A 0 entry in this table means the key corresponds
;  to a normal ASCII character, the value of which is found in the keynrm,
;  keyshf, or keyctl table, depending on the current state of the control and
;  shift keys.  An entry with the high bit clear means the key corresponds to
;  an extended character code - the value in this table is the value for the
;  second byte of that code.  An entry with the high bit set means the key
;  requires special handling - the value in this table is the index into a
;  dispatch table for special handling.

keytbl:	.BYTE	SK_NULL		;00
	.BYTE	35h		;01 - Escape key
	.BYTE	01h		;02 - 1 or !
	.BYTE	02h		;03 - 2 or @
	.BYTE	03h		;04 - 3 or #
	.BYTE	04h		;05 - 4 or $
	.BYTE	05h		;06 - 5 or %
	.BYTE	06h		;07 - 6 or ^
	.BYTE	07h		;08 - 7 or &
	.BYTE	08h		;09 - 8 or *
	.BYTE	09h		;0A - 9 or (
	.BYTE	0Ah		;0B - 0 or )
	.BYTE	0Bh		;0C - - or _
	.BYTE	0Ch		;0D - = or +
	.BYTE	34h		;0E - Backspace
	.BYTE	36h		;0F - Tab
	.BYTE	28h		;10 - Q
	.BYTE	2Eh		;11 - W
	.BYTE	1Ch		;12 - E
	.BYTE	29h		;13 - R
	.BYTE	2Bh		;14 - T
	.BYTE	30h		;15 - Y
	.BYTE	2Ch		;16 - U
	.BYTE	20h		;17 - I
	.BYTE	26h		;18 - O
	.BYTE	27h		;19 - P
	.BYTE	0Dh		;1A - [ or {
	.BYTE	0Eh		;1B - ] or }
	.BYTE	33h		;1C - Return
	.BYTE	SK_LCTRL	;1D - Left control key
	.BYTE	18h		;1E - A
	.BYTE	2Ah		;1F - S
	.BYTE	1Bh		;20 - D
	.BYTE	1Dh		;21 - F
	.BYTE	1Eh		;22 - G
	.BYTE	1Fh		;23 - H
	.BYTE	21h		;24 - J
	.BYTE	22h		;25 - K
	.BYTE	23h		;26 - L
	.BYTE	14h		;27 - ;
	.BYTE	15h		;28 - ' or "
	.BYTE	10h		;29 - Grave or ~
	.BYTE	SK_LSHFT	;2A - Left shift key
	.BYTE	0Fh		;2B - Backslash or |
	.BYTE	31h		;2C - Z
	.BYTE	2Fh		;2D - X
	.BYTE	1Ah		;2E - C
	.BYTE	2Dh		;2F - V
	.BYTE	19h		;30 - B
	.BYTE	25h		;31 - N
	.BYTE	24h		;32 - M
	.BYTE	11h		;33 - , or <
	.BYTE	12h		;34 - . or >
	.BYTE	13h		;35 - / or ?
	.BYTE	SK_RSHFT	;36 - Right shift key
	.BYTE	5Bh		;37 - Keypad *
	.BYTE	SK_LALT		;38 - Left ALT key
	.BYTE	32h		;39 - Space
	.BYTE	SK_NULL		;3A - Caps lock key
	.BYTE	38h		;3B - F1 key
	.BYTE	39h		;3C - F2 key
	.BYTE	3Ah		;3D - F3 key
	.BYTE	3Bh		;3E - F4 key
	.BYTE	3Ch		;3F - F5 key
	.BYTE	3Dh		;40 - F6 key
	.BYTE	3Eh		;41 - F7 key
	.BYTE	3Fh		;42 - F8 key
	.BYTE	40h		;43 - F9 key
	.BYTE	41h		;44 - F10 key
	.BYTE	SK_NULL		;45 - NUM LOCK
	.BYTE	SK_NULL		;46 - SCROLL LOCK
	.BYTE	54h		;47 - Keypad 7
	.BYTE	55h		;48 - Keypad 8
	.BYTE	56h		;49 - Keypad 9
	.BYTE	5Ch		;4A - Keypad - (!!)
	.BYTE	51h		;4B - Keypad 4
	.BYTE	52h		;4C - Keypad 5
	.BYTE	53h		;4D - Keypad 6
	.BYTE	5Ah		;4E - Keypad +
	.BYTE	4Eh		;4F - Keypad 1
	.BYTE	4Fh		;50 - Keypad 2
	.BYTE	50h		;51 - Keypad 3
	.BYTE	57h		;52 - Keypad 0
	.BYTE	SK_DEL2		;53 - Keypad .
	.BYTE	SK_NULL		;54
	.BYTE	SK_NULL		;55
	.BYTE	SK_NULL		;56
	.BYTE	42h		;57 - F11 key
	.BYTE	43h		;58 - F12 key

keytblE0:
	.BYTE	SK_NULL		;E0-00
	.BYTE	SK_NULL		;E0-01
	.BYTE	SK_NULL		;E0-02
	.BYTE	SK_NULL		;E0-03
	.BYTE	SK_NULL		;E0-04
	.BYTE	SK_NULL		;E0-05
	.BYTE	SK_NULL		;E0-06
	.BYTE	SK_NULL		;E0-07
	.BYTE	SK_NULL		;E0-08
	.BYTE	SK_NULL		;E0-09
	.BYTE	SK_NULL		;E0-0A
	.BYTE	SK_NULL		;E0-0B
	.BYTE	SK_NULL		;E0-0C
	.BYTE	SK_NULL		;E0-0D
	.BYTE	SK_NULL		;E0-0E
	.BYTE	SK_NULL		;E0-0F
	.BYTE	SK_NULL		;E0-10
	.BYTE	SK_NULL		;E0-11
	.BYTE	SK_NULL		;E0-12
	.BYTE	SK_NULL		;E0-13
	.BYTE	SK_NULL		;E0-14
	.BYTE	SK_NULL		;E0-15
	.BYTE	SK_NULL		;E0-16
	.BYTE	SK_NULL		;E0-17
	.BYTE	SK_NULL		;E0-18
	.BYTE	SK_NULL		;E0-19
	.BYTE	SK_NULL		;E0-1A
	.BYTE	SK_NULL		;E0-1B
	.BYTE	SK_NULL		;E0-1C
	.BYTE	SK_RCTRL	;E0-1D - Right control key
	.BYTE	SK_NULL		;E0-1E
	.BYTE	SK_NULL		;E0-1F
	.BYTE	SK_NULL		;E0-20
	.BYTE	SK_NULL		;E0-21
	.BYTE	SK_NULL		;E0-22
	.BYTE	SK_NULL		;E0-23
	.BYTE	SK_NULL		;E0-24
	.BYTE	SK_NULL		;E0-25
	.BYTE	SK_NULL		;E0-26
	.BYTE	SK_NULL		;E0-27
	.BYTE	SK_NULL		;E0-28
	.BYTE	SK_NULL		;E0-29
	.BYTE	SK_NULL		;E0-2A - Shift prefix (ignored)
	.BYTE	SK_NULL		;E0-2B
	.BYTE	SK_NULL		;E0-2C
	.BYTE	SK_NULL		;E0-2D
	.BYTE	SK_NULL		;E0-2E
	.BYTE	SK_NULL		;E0-2F
	.BYTE	SK_NULL		;E0-30
	.BYTE	SK_NULL		;E0-31
	.BYTE	SK_NULL		;E0-32
	.BYTE	SK_NULL		;E0-33
	.BYTE	SK_NULL		;E0-34
	.BYTE	59h		;E0-35 - Keypad /
	.BYTE	SK_NULL		;E0-36
	.BYTE	SK_NULL		;E0-37 - Print screen
	.BYTE	SK_RALT		;E0-38 - Right ALT key
	.BYTE	SK_NULL		;E0-39
	.BYTE	SK_NULL		;E0-3A
	.BYTE	SK_NULL		;E0-3B
	.BYTE	SK_NULL		;E0-3C
	.BYTE	SK_NULL		;E0-3D
	.BYTE	SK_NULL		;E0-3E
	.BYTE	SK_NULL		;E0-3F
	.BYTE	SK_NULL		;E0-40
	.BYTE	SK_NULL		;E0-41
	.BYTE	SK_NULL		;E0-42
	.BYTE	SK_NULL		;E0-43
	.BYTE	SK_NULL		;E0-44
	.BYTE	SK_NULL		;E0-45
	.BYTE	SK_NULL		;E0-46
	.BYTE	4Bh		;E0-47 - Home
	.BYTE	47h		;E0-48 - Up arrow
	.BYTE	4Dh		;E0-49 - Page up
	.BYTE	SK_NULL		;E0-4A
	.BYTE	45h		;E0-4B - Left arrow
	.BYTE	SK_NULL		;E0-4C
	.BYTE	46h		;E0-4D - Right arrow
	.BYTE	SK_NULL		;E0-4E
	.BYTE	4Ah		;E0-4F - End
	.BYTE	44h		;E0-50 - Down arrow
	.BYTE	4Ch		;E0-51 - Page down
	.BYTE	49h		;E0-52 - Insert
	.BYTE	SK_DEL1		;E0-53 - Delete
	.BYTE	SK_NULL		;E0-54
	.BYTE	SK_NULL		;E0-55
	.BYTE	SK_NULL		;E0-56
	.BYTE	SK_NULL		;E0-57
	.BYTE	SK_NULL		;E0-58
.PAGE
	.SBTTL	keynrm - Normal (unshifted) table

keynrm:	.BYTE	0		;00
	.BYTE	'1'		;01 - 1 or !
	.BYTE	'2'		;02 - 2 or @
	.BYTE	'3'		;03 - 3 or #
	.BYTE	'4'		;04 - 4 or $
	.BYTE	'5'		;05 - 5 or %
	.BYTE	'6'		;06 - 6 or ^
	.BYTE	'7'		;07 - 7 or &
	.BYTE	'8'		;08 - 8 or *
	.BYTE	'9'		;09 - 9 or (
	.BYTE	'0'		;0A - 0 or )
	.BYTE	'-'		;0B - - or _
	.BYTE	'='		;0C - = or +
	.BYTE	'['		;0D - [ or {
	.BYTE	']'		;0E - ] or }
	.BYTE	5Ch		;0F - Backslash or |
	.BYTE	'`'		;10 - Grave or ~
	.BYTE	','		;11 - , or <
	.BYTE	'.'		;12 - . or >
	.BYTE	'/'		;13 - / or ?
	.BYTE	';'		;14 - ;
	.BYTE	27h		;15 - ' or "
	.BYTE	0		;16
	.BYTE	0		;17
	.BYTE	'a'		;18 - A
	.BYTE	'b'		;19 - B
	.BYTE	'c'		;1A - C
	.BYTE	'd'		;1B - D
	.BYTE	'e'		;1C - E
	.BYTE	'f'		;1D - F
	.BYTE	'g'		;1E - G
	.BYTE	'h'		;1F - H
	.BYTE	'i'		;20 - I
	.BYTE	'j'		;21 - J
	.BYTE	'k'		;22 - K
	.BYTE	'l'		;23 - L
	.BYTE	'm'		;24 - M
	.BYTE	'n'		;25 - N
	.BYTE	'o'		;26 - O
	.BYTE	'p'		;27 - P
	.BYTE	'q'		;28 - Q
	.BYTE	'r'		;29 - R
	.BYTE	's'		;2A - S
	.BYTE	't'		;2B - T
	.BYTE	'u'		;2C - U
	.BYTE	'v'		;2D - V
	.BYTE	'w'		;2E - W
	.BYTE	'x'		;2F - X
	.BYTE	'y'		;30 - Y
	.BYTE	'z'		;31 - Z
	.BYTE	' '		;32 - Space
	.BYTE	CR		;33 - Return
	.BYTE	BS		;34 - Backspace
	.BYTE	ESC		;35 - Escape key
	.BYTE	HT		;36 - Tab
	.BYTE	0		;37
	.BYTE	81h		;38 - F1 key
	.BYTE	82h		;39 - F2 key
	.BYTE	83h		;3A - F3 key
	.BYTE	84h		;3B - F4 key
	.BYTE	85h		;3C - F5 key
	.BYTE	86h		;3D - F6 key
	.BYTE	87h		;3E - F7 key
	.BYTE	88h		;3F - F8 key
	.BYTE	89h		;40 - F9 key
	.BYTE	8Ah		;41 - F10 key
	.BYTE	8Bh		;42 - F11 key
	.BYTE	8Ch		;43 - F12 key
	.BYTE	0		;44 - Down arrow
	.BYTE	0		;45 - Left arrow
	.BYTE	0		;46 - Right arrow
	.BYTE	0		;47 - Up arrow
	.BYTE	0		;48 - Delete
	.BYTE	0		;49 - Insert
	.BYTE	0		;4A - End
	.BYTE	0		;4B - Home
	.BYTE	0		;4C - Page down
	.BYTE	0		;4D - Page up
	.BYTE	'1'		;4E - Keypad 1
	.BYTE	'2'		;4F - Keypad 2
	.BYTE	'3'		;50 - Keypad 3
	.BYTE	'4'		;51 - Keypad 4
	.BYTE	'5'		;52 - Keypad 5
	.BYTE	'6'		;53 - Keypad 6
	.BYTE	'7'		;54 - Keypad 7
	.BYTE	'8'		;55 - Keypad 8
	.BYTE	'9'		;56 - Keypad 9
	.BYTE	'0'		;57 - Keypad 0
	.BYTE	'.'		;58 - Keypad .
	.BYTE	'/'		;59 - Keypad /
	.BYTE	'+'		;5A - Keypad +
	.BYTE	'*'		;5B - Keypad *
	.BYTE	'-'		;5C - Keypad - (!!)
	.BYTE	CR		;5D - Keypad enter
	.BYTE	0		;5E - Pause
.PAGE
	.SBTTL	keyshf - Keyboard table with shift key pressed

keyshf:	.BYTE	0		;00
	.BYTE	'!'		;01 - 1 or !
	.BYTE	'@'		;02 - 2 or @
	.BYTE	'#'		;03 - 3 or #
	.BYTE	'$'		;04 - 4 or $
	.BYTE	'%'		;05 - 5 or %
	.BYTE	'^'		;06 - 6 or ^
	.BYTE	'&'		;07 - 7 or &
	.BYTE	'*'		;08 - 8 or *
	.BYTE	'('		;09 - 9 or (
	.BYTE	')'		;0A - 0 or )
	.BYTE	'_'		;0B - - or _
	.BYTE	'+'		;0C - = or +
	.BYTE	'{'		;0D - [ or {
	.BYTE	'}'		;0E - ] or }
	.BYTE	'|'		;0F - Backslash or |
	.BYTE	'~'		;10 - Grave or ~
	.BYTE	'<'		;11 - , or <
	.BYTE	'>'		;12 - . or >
	.BYTE	'?'		;13 - / or ?
	.BYTE	':'		;14 - ;
	.BYTE	'"'		;15 - ' or "
	.BYTE	0		;16
	.BYTE	0		;17
	.BYTE	'A'		;18 - A
	.BYTE	'B'		;19 - B
	.BYTE	'C'		;1A - C
	.BYTE	'D'		;1B - D
	.BYTE	'E'		;1C - E
	.BYTE	'F'		;1D - F
	.BYTE	'G'		;1E - G
	.BYTE	'H'		;1F - H
	.BYTE	'I'		;20 - I
	.BYTE	'J'		;21 - J
	.BYTE	'K'		;22 - K
	.BYTE	'L'		;23 - L
	.BYTE	'M'		;24 - M
	.BYTE	'N'		;25 - N
	.BYTE	'O'		;26 - O
	.BYTE	'P'		;27 - P
	.BYTE	'Q'		;29 - Q
	.BYTE	'R'		;28 - R
	.BYTE	'S'		;2A - S
	.BYTE	'T'		;2B - T
	.BYTE	'U'		;2C - U
	.BYTE	'V'		;2D - V
	.BYTE	'W'		;2E - W
	.BYTE	'X'		;2F - X
	.BYTE	'Y'		;30 - Y
	.BYTE	'Z'		;31 - Z
	.BYTE	' '		;32 - Space
	.BYTE	CR		;33 - Return
	.BYTE	BS		;34 - Backspace
	.BYTE	ESC		;35 - Escape key
	.BYTE	HT		;36 - Tab
	.BYTE	0		;37
	.BYTE	91h		;38 - F1 key
	.BYTE	92h		;39 - F2 key
	.BYTE	93h		;3A - F3 key
	.BYTE	94h		;3B - F4 key
	.BYTE	95h		;3C - F5 key
	.BYTE	96h		;3D - F6 key
	.BYTE	97h		;3E - F7 key
	.BYTE	98h		;3F - F8 key
	.BYTE	99h		;40 - F9 key
	.BYTE	9AH		;41 - F10 key
	.BYTE	9Bh		;42 - F11 key
	.BYTE	9Ch		;43 - F12 key
	.BYTE	0		;44 - Down arrow
	.BYTE	0		;45 - Left arrow
	.BYTE	0		;46 - Right arrow
	.BYTE	0		;47 - Up arrow
	.BYTE	0		;48 - Delete
	.BYTE	0		;49 - Insert
	.BYTE	0		;4A - End
	.BYTE	0		;4B - Home
	.BYTE	0		;4C - Page down
	.BYTE	0		;4D - Page up
	.BYTE	'1'		;4E - Keypad 1
	.BYTE	'2'		;4F - Keypad 2
	.BYTE	'3'		;50 - Keypad 3
	.BYTE	'4'		;51 - Keypad 4
	.BYTE	'5'		;52 - Keypad 5
	.BYTE	'6'		;53 - Keypad 6
	.BYTE	'7'		;54 - Keypad 7
	.BYTE	'8'		;55 - Keypad 8
	.BYTE	'9'		;56 - Keypad 9
	.BYTE	'0'		;57 - Keypad 0
	.BYTE	'.'		;58 - Keypad .
	.BYTE	'/'		;59 - Keypad /
	.BYTE	'+'		;5A - Keypad +
	.BYTE	'*'		;5B - Keypad *
	.BYTE	'-'		;5C - Keypad - (!!)
	.BYTE	CR		;5D - Keypad enter
	.BYTE	0		;5E - Pause
.PAGE
	.SBTTL	keyctr - Keyboard table with control key pressed

keyctl:	.BYTE	0		;00
	.BYTE	'1'		;01 - 1 or !
	.BYTE	'2'		;02 - 2 or @
	.BYTE	'3'		;03 - 3 or #
	.BYTE	'4'		;04 - 4 or $
	.BYTE	'5'		;05 - 5 or %
	.BYTE	'6'		;06 - 6 or ^
	.BYTE	'7'		;07 - 7 or &
	.BYTE	'8'		;08 - 8 or *
	.BYTE	'9'		;09 - 9 or (
	.BYTE	'0'		;0A - 0 or )
	.BYTE	'-'		;0B - - or _
	.BYTE	'='		;0C - = or +
	.BYTE	ESC		;0D - [ or {
	.BYTE	']'		;0E - ] or }
	.BYTE	5Ch		;0F - Backslash or |
	.BYTE	'`'		;10 - Grave or ~
	.BYTE	','		;11 - , or <
	.BYTE	'.'		;12 - . or >
	.BYTE	'/'		;13 - / or ?
	.BYTE	';'		;14 - ;
	.BYTE	27h		;15 - ' or "
	.BYTE	0		;16
	.BYTE	0		;17
	.BYTE	'A'-40h		;18 - A
	.BYTE	'B'-40h		;19 - B
	.BYTE	'C'-40h		;1A - C
	.BYTE	'D'-40h		;1B - D
	.BYTE	'E'-40h		;1C - E
	.BYTE	'F'-40h		;1D - F
	.BYTE	'G'-40h		;1E - G
	.BYTE	'H'-40h		;1F - H
	.BYTE	'I'-40h		;20 - I
	.BYTE	'J'-40h		;21 - J
	.BYTE	'K'-40h		;22 - K
	.BYTE	'L'-40h		;23 - L
	.BYTE	'M'-40h		;24 - M
	.BYTE	'N'-40h		;25 - N
	.BYTE	'O'-40h		;26 - O
	.BYTE	'P'-40h		;27 - P
	.BYTE	'Q'-40h		;29 - Q
	.BYTE	'R'-40h		;28 - R
	.BYTE	'S'-40h		;2A - S
	.BYTE	'T'-40h		;2B - T
	.BYTE	'U'-40h		;2C - U
	.BYTE	'V'-40h		;2D - V
	.BYTE	'W'-40h		;2E - W
	.BYTE	'X'-40h		;2F - X
	.BYTE	'Y'-40h		;30 - Y
	.BYTE	'Z'-40h		;31 - Z
	.BYTE	' '		;32 - Space
	.BYTE	CR		;33 - Return
	.BYTE	BS		;34 - Backspace
	.BYTE	ESC		;35 - Escape key
	.BYTE	HT		;36 - Tab
	.BYTE	0		;37
	.BYTE	0		;38 - F1 key
	.BYTE	0		;39 - F2 key
	.BYTE	0		;3A - F3 key
	.BYTE	0		;3B - F4 key
	.BYTE	0		;3C - F5 key
	.BYTE	0		;3D - F6 key
	.BYTE	0		;3E - F7 key
	.BYTE	0		;3F - F8 key
	.BYTE	0		;40 - F9 key
	.BYTE	0		;41 - F10 key
	.BYTE	0		;42 - F11 key
	.BYTE	0		;43 - F12 key
	.BYTE	0		;44 - Down arrow
	.BYTE	0		;45 - Left arrow
	.BYTE	0		;46 - Right arrow
	.BYTE	0		;47 - Up arrow
	.BYTE	0		;48 - Delete
	.BYTE	0		;49 - Insert
	.BYTE	0		;4A - End
	.BYTE	0		;4B - Home
	.BYTE	0		;4C - Page down
	.BYTE	0		;4D - Page up
	.BYTE	'1'		;4E - Keypad 1
	.BYTE	'2'		;4F - Keypad 2
	.BYTE	'3'		;50 - Keypad 3
	.BYTE	'4'		;51 - Keypad 4
	.BYTE	'5'		;52 - Keypad 5
	.BYTE	'6'		;53 - Keypad 6
	.BYTE	'7'		;54 - Keypad 7
	.BYTE	'8'		;55 - Keypad 8
	.BYTE	'9'		;56 - Keypad 9
	.BYTE	'0'		;57 - Keypad 0
	.BYTE	'.'		;58 - Keypad .
	.BYTE	'/'		;59 - Keypad /
	.BYTE	'+'		;5A - Keypad +
	.BYTE	'*'		;5B - Keypad *
	.BYTE	'-'		;5C - Keypad - (!!)
	.BYTE	CR		;5D - Keypad enter
	.BYTE	0		;5E - Pause
.PAGE
	.MACRO	& SCNMSG  attr, string
	.IRPC	&& qq,{string}
	.BYTE	'qq', attr
	.ENDR
	.ENDM

	.RADIX	10t
	.IRP	maj, >MAJVER
	.IRP	min, >MINVER
	.IRP	& edit, >EDITNUM
lblmsg:	SCNMSG	1, { GECKO (real mode) v&maj.&min.&edit }
	.ENDR
	.ENDR
	.ENDR
LBLSIZE=!{$-lblmsg}/2

	.RADIX	16t
cprmsg:	SCNMSG	0, {1}
	SCNMSG	1, {Help}
	SCNMSG	0, { 2}
	SCNMSG	1, {SwScrn}
	SCNMSG	0, { 4}
	SCNMSG	1, {ExmEIP}
	SCNMSG	0, { 5}
	SCNMSG	1, {ExmPrev}
	SCNMSG	0, { 6}
	SCNMSG	1, {ExmSame}
	SCNMSG	0, { 7}
	SCNMSG	1, {ExmNext}
	SCNMSG	0, { 8}
	SCNMSG	1, {Step}
	SCNMSG	0, { 9}
	SCNMSG	1, {Trace}
	SCNMSG	0, {10}
	SCNMSG	1, {Go}
CPRSIZE=!{$-cprmsg}/2

cncech:	 .ASCIZ	"^C"{CR}{LF}	;Echo for control C
quitflg::.BYTE	0		;Set non-zero by quit command

scrtbl:	.BYTE	6,  0t	;EAX
	.BYTE	6,  1t	;EBX
	.BYTE	6,  2t	;ECX
	.BYTE	6,  3t	;EDX
	.BYTE	6,  7t	;EDI
	.BYTE	6,  6t	;ESI
	.BYTE	6,  5t	;EBP
	.BYTE	6,  4t	;ESP
	.BYTE	5, 11t	;ES
	.BYTE	5,  8t	;CS
	.BYTE	5,  9t	;SS
	.BYTE	5, 10t	;DS
	.BYTE	5, 12t	;FS
	.BYTE	5, 13t	;GS
	.BYTE	6, 14t	;EIP
	.BYTE	6, 15t	;EFR

	DATA

nonscrl: .BYTE	0	;Non-zero to output to nonscrolled region
attrib:	 .BYTE	CTXTATR	;Current character attributes
			;Following 4 item must be in this order!
brdatr:	 .BYTE	CBRDATR	;Attribute value for border characters
ibdatr:	 .BYTE	CIBDATR	;Attribute value for inverse border characters
txtatr:	 .BYTE	CTXTATR	;Attribute value for text characters
erratr:	 .BYTE	CERRATR	;Attribute value for error message characters
invatr:	 .BYTE	CINVATR	;Attribute value for inverse characters

	 .MOD	2
curport: .WORD	0	;Port number of display controller cursor register
sclladdr:.WORD	6*160t	;Address of scrolling area
dispseg: .WORD	0
xcursor: .WORD	0	;GECKO cursor location while user screen is displayed
nscladdr:.WORD	160t	;Address of nonscrolling area
	 .WORD	0

scllsiz: .WORD	18t	;Size of scrolling area (lines)
curlin:	 .WORD	0	;Current line in scrolling region
screen:	 .WORD	0	;Non-zero when GECKO's screen is displayed
horpsn:	 .LONG	0	;Horizontal position in current line
verpsn:	 .LONG	0	;Vertical position of start of current line

kbdsta:  .WORD	kbdnorm	;Keyboard input state dispatch offset
hltflg:	 .WORD	0	;Non-zero if need to halt GECKO
nohalt:	 .WORD	0	;Non-zero if cannot halt because in critical code
stpflg:	 .WORD	0	;Non-zero to stop output
kbdcnt:	 .WORD	0	;Count of characters in keyboard buffer
kbdput:	 .LONG	0	;Keyboard buffer putter pointer
kbdtak:	 .LONG	0	;Keyboard buffer taker pointer
savi3v:	 .LONG	0	;Place to save user's INT 3 vector
savttv:	 .LONG	0	;Place to save user's trace trap vector
xscrlbf: .ADDRL	xdispbf+6*160t ;Address of scrolling region
	 .WORD	0
xnsclbf: .ADDRL	xdispbf+160t ;Address of nonscrolling region
keysts:	 .WORD	0	;Keyboard shift status bits
keybkf:	 .BYTE	0	;Keyboard break code flag
dsptype::.BYTE	5	;Display type
intmask: .BYTE	0	;Saved interrupt enables
allregs: .BYTE	0	;Non-0 if should send all register values to serial
			;  client

	 .MOD	4
uregvalue:
	 .BLKL	16t	;Current register values for serial client
kbdbfr:	 .BLKW	KBDSIZE	;The keyboard buffer
kbdend:
xdispbf::.BLKW	4*1024t	;GECKO display buffer
udispbf: .BLKW	4*1024t	;User display buffer

	CODE
.PAGE
