	.TITLE	TCPCLS2 - TCP routines for XOS (part 2)

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXIPS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTCP.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

	LKECONT

;This file contains routines for receiving packets

$$TCPTIME=!0			;Define this non-zero to include TCP retransmit
				;  time ring buffer for debugging, ring
				;  allocated contains $$TCPTIME * 1024 items
				;  (16 bytes per item)

	.EXPORT	xostcpFatal   , xostcpChkWin  , xostcpAlloc
	.EXPORT	xostcpPush    , xostcpGiveSnd , xostcpGetByte
	.EXPORT	xostcpGetWord , xostcpGetLong , xostcpGetBlk
	.EXPORT	xostcpPutByte , xostcpPutWord , xostcpPutLong
	.EXPORT	xostcpPutBlk  , xostcpHashSet , xostcpHashClr
	.EXPORT	xostcpTimerReq, xostcpTimerRmv, xostcpOpenWindow
	.EXPORT	xostcpSendAck , xostcpGiveAll

;Subroutine to process received TCP packet
;	c{EAX} = Offset of IDB
;	c{EBX} = Offset of packet buffer
;?????	c{ECX} = TCP length
;?????	c{EDX} = Offset of start of TCP header
;	c{EDI} = Offset of PDB
;	c{ESI} = Offset of TPDB
;	CALL	tcprcv

$$$=!0
FRM rcv_pkt   , 4t
FRM rcv_tcphdr, 4t
FRM rcv_tcplen, 4t
FRM rcv_pdb   , 4t
FRM rcv_tpdb  , 4t
rcv_SIZE=!$$$

;Here if packet size is less than minimum

2$:	INCL	tpdb_tcpcntpsltmn[ESI]
	JMP	ignorey

;Here if header length is less than minimum - report as bad header

4$:	INCL	tpdb_tcpcntbadhdr[ESI]
	JMP	ignorey

;Here if packet size is less that header length

6$:	INCL	tpdb_tcpcntpslthl[ESI]	;Count the error
	JMP	ignorey			;And discard the input packet

;Here if have checksum error

8$:	MOVL	ESI, rcv_tpdb.B[EBP]
	INCL	tpdb_tcpcntchksum[ESI]	;Count the error and discard the packet
	JMP	ignorey

;Start of routine

tcprcv::CMPW	npb_magic.B[EBX], #NPB_MAGIC ;Is this really a network buffer?
	JE	10$.S			;Yes
	CRASH	NANB			[Not A Network Buffer]

10$:	ENTER	rcv_SIZE, 0		;Set up our stack frame
	MOVL	rcv_pkt.B[EBP], EBX	;Save offset of packet buffer
	MOVZBL	ECX, npb_tpofs.B[EBX]
	NEGL	ECX
	ADDL	ECX, npb_count.B[EBX]
	MOVL	rcv_tcplen.B[EBP], ECX	;Save length of TCP part of packet
	MOVL	rcv_tcphdr.B[EBP], EDX	;Save offset of TCP header
	MOVL	rcv_pdb.B[EBP], EDI	;Save offset of PDB
	MOVL	rcv_tpdb.B[EBP], ESI	;Save offset of TPDB
	CMPL	ECX, #16t.B		;Packet big enough for a minimum header?
	JB	2$.S			;No - discard it
	MOVZBL	EAX, tcp_offset.B[EDX]	;Yes - get length of TCP header
	SHRL	EAX, #2
	ANDB	AL, #0FCh
	CMPL	EAX, #16t.B		;Is it at least the minimum?
	JB	4$.S			;No - discard it
	CMPL	EAX, ECX		;Yes - packet long enough for header?
	JA	6$.S			;No - discard it
	TESTB	pdb_ipchksumh[EDI], #PCSH$CHK ;Yes - need to check the checksum?
	JE	tcprcv4.S		;No - go on
	PUSHL	ESI			;Yes
	MOVZBL	ESI, npb_npofs.B[EBX]	;
	LEAL	ESI, ip_srcipaddr.B[EBX+ESI] ;Point to IP source address
	CLD
	LODSL	[ESI]			;Get 2 words
	ADDL	EAX, [ESI]		;Add in next 2 words
	ADCL	EAX, #0.B
	MOVL	ESI, EDX
	PUSHL	ECX
	XCHGB	CL, CH
	SHLL	ECX, #16t
	MOVB	CH, #IPP_TCP		;Include the protocol value
	ADDL	EAX, ECX		;Add into checksum value
	ADCL	EAX, #0.B
	POPL	ECX
	CALL	xosipsChkSumFin##
	POPL	ESI
	CMPW	AX, #0FFFFFFFFh.B	;Is the checksum value correct?
	JNE	8$			;No
	MOVL	EDX, rcv_tcphdr.B[EBP]	;Yes - restore offset of the TCP header
					;Fall into tcprcv4 on next page
.PAGE
;Here with TCP checksum processed - either we don't care about it or it was
;  correct

tcprcv4:MOVZBL	ECX, npb_npofs.B[EBX]
	MOVL	ECX, ip_srcipaddr.B[EBX+ECX] ;Get source IP address
	PUSHL	ECX
	MOVZBL	EBX, CL
	ROLB	BL, #1
	XORB	BL, CH
	SHRL	ECX, #16t
	ROLB	BL, #1
	XORB	BL, CL
	ROLB	BL, #1
	XORB	BL, CH
	POPL	ECX
	MOVL	EAX, [EDX]		;Get destination and source ports
	RORL	EAX, #16t		;Calculate hash table index
	ROLB	BL, #1
	XORB	BL, AH
	ROLB	BL, #1
	XORB	BL, AL
	RORL	EAX, #16t
	ROLB	BL, #1
	XORB	BL, AL
	ROLB	BL, #1
	XORB	BL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	EDI, tpdb_tcprcvhash[ESI] ;Get first DCB in hash chain
	MOVL	EDI, [EDI+EBX*4]
	MOVL	EBX, rcv_pkt.B[EBP]	;Restore offset of packet buffer
	TESTL	EDI, EDI		;More to check?
	JE	8$.S			;No - discard the packet
4$:	CMPL	dcb_ipsrmtaddr.B[EDI], ECX ;Check remote IP address
	JNE	6$.S			;Different
	CMPL	dcb_ipslclport.B[EDI], EAX ;Same - check ports
	JE	12$.S			;Same - we found it!
6$:	MOVL	EDI, dcb_ipshashnext[EDI] ;Different - advance to next DCB
	TESTL	EDI, EDI
	JNE	4$.S			;Continue if more to check
8$:	MOVL	EDI, rcv_pdb.B[EBP]	;Not there - restore offset of the PDB
	MOVB	AL, tcp_code.B[EDX]
	ANDB	AL, #~TCPC$PSH
	CMPB	AL, #TCPC$SYN		;Is this a SYN?
	JE	newsyn			;Yes - go handle that
	CMPB	AL, #TCPC$FIN|TCPC$ACK	;No - is it a FIN|ACK?
	JE	newfinack		;Yes - go handle that case!
ignorex:MOVL	EAX, rcv_tpdb.B[EBP]
	INCL	tpdb_tcpcntnodst[EAX]	;Count the discarded packet
ignorey:MOVL	EBX, rcv_pkt.B[EBP]	;Make sure have packet buffer offset
	LEAVE
	CALL	xosnetGiveBufr##	;Give up the packet buffer
10$:	RET

;Here with DCB for this packet

12$:	MOVL	ECX, rcv_tcplen.B[EBP]	;Restore TCP length
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Get offset of the TPDB
	INCL	tpdb_tcpcntpktin.B[EAX]
	ADDL	tpdb_tcpcntbytein.B[EAX], ECX
	ANDB	dcb_tcpsts1.B[EDI], #~{TCPS1$ACKED|TCPS1$OPENED}
	MOVZBL	EAX, dcb_tcpstate.B[EDI] ;Get connection state
	CALLI	CS:rcvdsp[EAX*4]	;Dispatch on the state
	LEAVE				;Give up the rcv_ frame
	TESTL	EDI, EDI		;Still have a DCB?
	JE	10$.S			;No - finished now
	TESTB	dcb_tcpsts1.B[EDI], #TCPS1$ACKED|TCPS1$OPENED
					;Yes - did we change the window or ACK
					;  anything?
	JE	10$.S			;No
					;Yes - fall into chksend on next page
.PAGE
;Here with ACK or window change - we need to scan the send list and adjust the
;  output counts for each packet so we only send data that is in the window.
;  The counts need to be changed in two cases: First, if we are sending a
;  partial packet to fill out the window or a window probe and the window opens;
;  or second, if the receiver reduces his window after we have output data
;  (this is not legal, but we have to allow for it according to RFC1122).  This
;  can leave us with some packets on the held list with a zero output count.
;  If we were retransmitting we retransmit the first held packet (even if it
;  has already been transmitted).  If we were not retransmitting, we transmit
;  all held packets which have not been transmitted and which are in completely
;  in the send window.  We then poke anyone waiting on the window if the window
;  is non-zero.  (We don't need to poke if the window is 0 since we already
;  have a probe packet queued here.)  We also need to restart the retransmit
;  timer (also used for probes).  Note that the normal response for a probe
;  packet (if the window is still closed) is an ACK which does not ACK anything,
;  so it will not cause this code to be executed.

;  We don't do this until all other processing (including accepting input) is
;  done so that any output packets generated here will acknowlege input which
;  we might have just received.

chksend:CALL	xostcpTimerRmv		;Stop the timer
	MOVL	EBX, dcb_tcpsndhead[EDI] ;Get first packet in the send list
	TESTL	EBX, EBX
	JE	chkwake			;If none
	MOVL	EAX, npb_seqnum.B[EBX]	;Make sure sequence numbers are OK
	CMPL	dcb_tcprcvanum.B[EDI], EAX
	JNE	4$.S
	MOVL	ECX, dcb_tcpsndwina[EDI]   ;Get total window amount (available
	ADDL	ECX, dcb_tcpsndsnum[EDI]   ;  window size adjusted for held
	SUBL	ECX, dcb_tcprcvanum.B[EDI] ;  packets)

;Here with packet whose count needs to be recaluclated.  There are four
;  possibities here:
;	The packet fits completely in the window
;		Output count = size of packet
;	The packet fits partly in the window
;		Output count = amount which fits in window
;	The window is 0 or negative and this is the first held packet
;		Output count = 1 (window probe)
;	The window is 0 or negative and this is not the first held packet
;		Output count = 0
;  Note that a window of -1 is normal when sending a window probe.  A window
;    of less than -1 is possible if the other side reduced his window to less
;    than what we had sent!
;If we are not retransmitting, this code also outputs all held packets which
;  fit completely in the window which have not been sent yet.  It also outputs
;  any packets which were overcommitted but are not now overcommitted, even
;  if they have been sent before (this should only happen if the receiver
;  reduces his window size).  If we were retransmitting, it outputs the first
;  held packet (only) even if it has already been sent.

2$:	MOVL	EAX, npb_apcnt.B[EBX]	;Get data length of packet
	CMPL	EAX, ECX		;Will this packet fit completely in
					;  the window?
	JLE	10$.S			;Yes
	CLRL	ECX			;No
	MOVL	npb_count.B[EBX], ECX	;Yes - make the output count 0
	TESTB	npb_sts.B[EBX], #NPS$OVRCMTD ;Was this packet overcommitted?
	JNE	20$.S			;Yes
	INCL	dcb_tcpsndover[EDI]	;No - count the overcommitted packet
	ORB	npb_sts.B[EBX], #NPS$OVRCMTD
	JMP	20$.S			;Continue

4$:	CRASH	SEQ6

8$:	CRASH	BOVR

;Here if packet will fit completely in the window

10$:	SUBL	ECX, EAX		;Reduce amount available in window
	MOVZBL	EDX, npb_apofs.B[EBX]	;Calculate output count
	ADDL	EDX, EAX
	MOVL	npb_count.B[EBX], EDX	;Store output count for packet
	TESTB	npb_sts.B[EBX], #NPS$OVRCMTD ;Was the packet overcommitted?
	JE	12$.S			;No
	ANDB	npb_sts.B[EBX], #~NPS$OVRCMTD ;Yes, but it is not now
	SUBL	dcb_tcpsndwina[EDI], EAX ;Reduce available window to account
					 ;  for this packet	
	DECL	dcb_tcpsndover[EDI]	;Reduce number of overcommitted packets
	JS	8$.S
	JMP	14$.S			;Always output it

;Here if packet was not overcommitted

12$:	TESTB	dcb_tcpsts1.B[EDI], #TCPS1$REXMIT ;Were we retransmitting?
	JNE	14$.S			;Yes
	TESTB	npb_sts.B[EBX], #NPS$XMITD ;No - has the packet been sent yet?
	JNE	18$.S			;Yes - don't send it now
14$:	CMPL	npb_nextsnd.B[EBX], #-1.B ;No - is the packet being output now?
	JNE	18$.S			;Yes - can't output it again!
	PUSHL	ECX
	CALL	tcpsendpk2		;No - output the packet now
	POPL	ECX
18$:	MOVL	EAX, npb_seqnum.B[EBX]	;Calculate next sequence number
	ADDL	EAX, npb_apcnt.B[EBX]
	CMPL	dcb_tcpsndsnum[EDI], EAX ;Is this a new value?
	JNS	20$.S			;No
	MOVL	dcb_tcpsndsnum[EDI], EAX ;Yes - update the send number
20$:	MOVL	EBX, npb_next.B[EBX]	;Advance to next packet in the held list
	TESTL	EBX, EBX
	JNE	2$			;Continue if have another
					;No more packets in list

;Here with all packets in the send list processed - now see if we need to wake
;  up anyone and also restart the retransmit timer

chkwake:ANDB	dcb_tcpsts1.B[EDI], #~TCPS1$REXMIT ;No longer retransmitting
	MOVB	dcb_tcpretrycnt.B[EDI], #0 ;Reset retransmit counter
	MOVL	EAX, dcb_tcpsndsnum[EDI] ;Have any un-ACKed packets?
	CMPL	EAX, dcb_tcprcvanum.B[EDI]
	JNE	24$.S			;Yes
	MOVL	EBX, dcb_tcpsndpktb[EDI] ;No - have a pending output packet?
	TESTL	EBX, EBX
	JE	24$.S			;No
	TESTB	npb_sts.B[EBX], #NPS$PUSHED ;Yes - has it been pushed yet?
	JE	24$.S			;No
	CALL	tcppushu		;Yes - output it now
24$:	CMPL	dcb_tcpsndhead[EDI], #0.B ;Have any packets in the held list?
	JE	26$.S			;No
	CALL	tcprexmitreq		;Yes - restart the timer
	CMPL	dcb_tcprxmtbgn[EDI], #0.B ;Are we timing a packet now?
	JNE	26$.S			;Yes
	MOVL	EAX, knlTickTtl##	 ;No - store current time for
	MOVL	dcb_tcprxmtbgn[EDI], EAX ;  retransmission timing
26$:	CMPL	dcb_tcpsndwina[EDI], #0.B ;Is the window open at all now?
	JLE	30$.S			;No - all finished here
	CLRL	EAX			;Yes
	MOVL	ECX, dcb_tcpfuncdisp.B[EDI] ;Wake up application to send more
	JMPIL	CS:tcpf_needout.B[ECX]	    ;  data

30$:	RET
.PAGE
;TCP connection state dispatch table for received packets

	.MOD	4
rcvdsp:	.LONG	ignore		;TCPS_CLOSED    = 0  - Idle
	.LONG	0		;TCPS_LISTEN    = 1  - Waiting for SYN
	.LONG	rcvsynsent	;TCPS_SYNSENT   = 2  - SYN sent
	.LONG	rcvsynackd	;TCPS_SYNACKD   = 3  - ACK sent for SYN|ACK
	.LONG	rcvsynrcvd	;TCPS_SYNRCVD   = 4  - SYN received
	.LONG	rcvestab	;TCPS_ESTAB     = 5  - Connection established
	.LONG	rcvfinwait	;TCPS_FINWAIT1  = 6  - FIN sent, waiting for FIN
				;			 in reply and for ACK
	.LONG	rcvfinwait	;TCPS_FINWAIT2  = 7  - ACK for FIN received,
				;			 still waiting for FIN
	.LONG	rcvclosing	;TCPS_CLOSING   = 8  - Reply FIN received
				;			 without ACK, waiting
				;			 for ACK for the FIN
	.LONG	rcvclosewait	;TCPS_CLOSEWAIT = 9  - FIN received, waiting
				;			 for process to close
				;			 TCP device
	.LONG	rcvlastack	;TCPS_LASTACK   = 10 - Reply FIN sent, waiting
				;			 for final ACK
	.LONG	ignore		;TCPS_TIMEWAIT  = 11 - All finished - timing out
				;			 port
.PAGE
;Here with SYN packet which does not have a matching DCB - this may be an
;  in-coming connection request
;	c{EBX} = Offset of packet buffer
;	c{EDX} = Offset of TCP packet header

;We use three parallel mechanisms to handle incoming connections.  The first
;  uses a pending open request to create a DCB in the TCPS_LISTEN state.  The
;  second uses a DCB with a non-zero incoming connection queue limit.  The
;  incoming SYN packets are linked to this DCB and then passed to DCBs created
;  as the result of an open with a matching IOPAR_NETCONHNDL parameter. The
;  third creates a new DCB when the request is received and sends an IPM
;  message to a program associated with the port.  We first look for a DCB in
;  the TCPS_LISTEN state, then we look for an IPM message destination
;  specification for the port.

;Currently, all three methods are fully supported for compatability with
;  existing programs but methods 1 and 3 are depricated and will eventually
;  not be supported.  All new code should use the second method described
;  above.

newsyn:	MOVL	ECX, rcv_pdb.B[EBP]
	MOVZWL	EAX, tcp_dstport.B[EDX]	;Get destination port number
	XCHGB	AL, AH
	LEAL	EBX, pdb_ipsynhead[ECX]	;Get offset of head pointer
4$:	MOVL	EDI, [EBX]		;Get next DCB
	TESTL	EDI, EDI
	JE	nosynwt			;No more - refuse the connection
	CMPW	dcb_ipslclport.B[EDI], AX ;For this port?
	JE	6$.S			;Yes
	LEAL	EBX, dcb_ipshashnext[EDI] ;No - advance to next
	JMP	4$.S

;Here with DCB which is waiting for a connection on the right port

6$:	MOVL	EBX, rcv_pkt.B[EBP]	;Restore pointer to packet buffer
	CMPW	dcb_tcpconlimit[EDI], #0.B ;Is the connection queue limit 0?
	JNE	10$.S			;No
	CMPL	dcb_tcprcvputb.B[EDI], #0.B ;Yes - this is a type 1 DCB - is
					    ;  the pointer free?
	JNE	ignorey			;No - ignore the packet!
	MOVL	dcb_tcprcvputb.B[EDI], EBX ;Yes - save offset of packet data
	MOVL	dcb_tcprcvputp.B[EDI], EDX
	MOVZWL	EAX, tcp_window.B[EDX]	;Get window size
	XCHGB	AL, AH
	MOVL	dcb_tcpsndwina[EDI], EAX ;Store it
	MOVL	dcb_tcpsndwinm[EDI], EAX
	LEAVE
	CLRL	EAX
	MOVL	EDX, dcb_tcpfuncdisp.B[EDI]
	JMPIL	CS:tcpf_synrcvd.B[EDX]

;Here with a matching DCB with a non-zero incoming connection queue limit

10$:	MOVZWL	ECX, dcb_tcpconlimit[EDI]
12$:	LEAL	EAX, dcb_tcprcvputb.B[EDI]
	CMPL	[EAX], #0.B
	JE	14$.S
	MOVL	EAX, [EAX]
	ADDL	EAX, #npb_next.B
	LOOP	ECX, 12$
	JMP	ignorey			;Queue limit exceeded - ignore this
					;  packet

;Here with the end of the list

14$:	MOVL	[EAX], EBX		;Put this packet on the end of the
	MOVL	npb_next.B[EBX], #0	;  packet list
	MOVL	EAX, dcb_tcpconnext[EDI] ;Is someone waiting for this?
	TESTL	EAX, EAX
	JE	16$.S			;No
	MOVL	EDX, dcb_tcpconnext[EAX] ;Yes - remove him from the list
	MOVL	dcb_tcpconnext[EDI], EDX
	CLRL	EDX
	MOVL	dcb_tcpconnext[EAX], EDX
	MOVL	dcb_tcpconbase[EAX], EDX
	PUSHL	EDI
	MOVL	EDI, EAX
	CLRL	EAX
	CALL	knlResumeOutput##
	POPL	EDI
16$:	LEAVE				;Finished
	RET
.PAGE
;Here if no one is waiting for a connection on the port - see if anyone is
;  using a type 2 "passive open" which uses a special device characteristic
;  and an IPM message

nosynwt:MOVL	EDX, tpdb_tcpcondsthead.B[ESI] ;Get first CON* device
12$:	TESTL	EDX, EDX		       ;  characteristics block
	JE	synrej			;If no more
	CMPL	dct_tcpport.B[EDX], EAX	;For this port?
	JE	16$.S			;Yes
	MOVL	EDX, dct_lnknext.B[EDX]	;No - advance to next
	JMP	12$.S			;Continue

;Here with a CON* device characteristics block for the port

16$:	PUSHL	EDX			;Save offset of the device
	PUSHL	tpdb_name+12t.B[ESI]	;  characteristics block
	PUSHL	tpdb_name+8.B[ESI]	;Device name
	PUSHL	tpdb_name+4.B[ESI]
	PUSHL	tpdb_name+0.B[ESI]
	MOVZBL	EAX, tpdb_unit.B[ESI]	;Primary unit number
	PUSHL	EAX
	PUSHL	#0FFFFh			;Assign a secondary unit number
	PUSHL	tpdb_dcbsizex.B[ESI]	;Size index
	PUSHL	tpdb_ccb.B[ESI]		;Offset of CCB
	MOVL	EAX, tpdb_pdb.B[ESI]
	PUSHL	pdb_idb.B[EAX]		;Offset of IDB
	PUSHL	#DS$DUPLEX		;Description bits
	CALL	xosnetMakeDcb##		;Get a network DCB
	JC	synrej			;If error
	MOVL	dcb_sdisp.B[EDI], #tcpdsp# ;Store offset of SVC dispatch table
	MOVB	dcb_ipsprot.B[EDI], #IPP_TCP ;Store IP protocol value
	MOVL	dcb_netmode.B[EDI], #NMTCP$PUSH|NMTCP$CONP ;Set default modes
	MOVL	dcb_devchar.B[EDI], #tcpdctbl# ;Use our device characteristics
	MOVL	dcb_tcpfuncdisp.B[EDI], #xostcpFncDisp#
	MOVL	EBX, rcv_tpdb.B[EBP]	;Restore offset of the TPDB
	MOVW	AX, tpdb_tcpretry1.B[EBX] ;Store default retransmission
	MOVW	dcb_tcpretry1.B[EDI], AX  ;  threshold values
	CALL	xosipsSetUpDcb##	;Finish setting up the TCP DCB
	MOVL	EAX, #10t*TICKSPERSEC	;Start a timer in case no one opens
	MOVL	EBX, #newcontimeout	;  this device soon
	CALL	xostcpTimerReq
	JC	22$.S			;If error starting the timer
	POPL	EDX
	PUSHL	EDI
	LEAL	EBX, dcb_name.B[EDI]	  ;Send IPM message to the associated
	LEAL	ESI, dct_tcpmsgdst.B[EDX] ;  process
	MOVL	EDI, #tcpsrcstr
	CLRL	ECX
	MOVL	EDX, #3100h
	CALL	knlSendLogInMsg##
	POPL	EDI
	JC	20$.S			;If error sending the IPM message
	MOVL	EBX, rcv_pkt.B[EBP]	;OK
	MOVL	dcb_tcprcvputb.B[EDI], EBX ;Store offset of the CONREQ packet
	MOVL	EAX, rcv_tcphdr.B[EBP]
	MOVL	dcb_tcprcvputp.B[EDI], EAX
	MOVL	npb_next.B[EBX], #0
	MOVL	EDX, rcv_tcphdr.B[EBP]
	MOVZWL	EAX, tcp_srcport.B[EDX]	;Get the remote port number
	MOVW	dcb_ipsrmtport.B[EDI], AX
	MOVZBL	ECX, npb_npofs.B[EBX]
	MOVL	EAX, ip_srcipaddr.B[EBX+ECX] ;Get the remote IP address
	MOVL	dcb_ipsrmtaddr.B[EDI], EAX
	MOVZWL	ECX, tcp_dstport.B[EDX]	;Get the local port number
	XCHGB	CL, CH
	BTSL	ECX, #30t		;Allow duplicates
	CALL	xosipsGetPort##		;Assign the port
	JC	24$.S			;This cannot fail!
;;;;;;	CALL	tcpcalhash		;Calculate hash index
;;;;;;	CALL	xostcpHashSet		;Put this DCB into the recive hash table
	MOVB	dcb_tcpstate.B[EDI], #TCPS_SYNRCVD ;Set TCP state
	LEAVE				;Thats all
	RET

;Here if error sending message to process

20$:	CALL	xostcpTimerRmv		;Remove the timer we just started

;Here if error starting the timer

22$:	CALL	xostcpGiveDcb#		;Give up the DCB we just made
	JMP	synrej.S		;Go reject the connection

;Here if error returned by xosipsGetPort (impossible!)

24$:	CRASH	GTPT
.PAGE
;Here if no one is waiting for a connection on the port

synrej:	MOVL	ESI, rcv_tpdb.B[EBP]	;Get offset of TPDB
	MOVL	EDI, tpdb_pdb.B[ESI]	;Get offset of PDB
	MOVL	EBX, rcv_pkt.B[EBP]	;Restore offset of packet buffer
	MOVL	EDX, rcv_tcphdr.B[EBP]	;Restore offset of TCP header
	LEAVE
newsy2:	PUSHL	tcp_srcport.B[EDX]	;Save source and destination ports
	PUSHL	tcp_seqnum.B[EDX]	;Save sequence number
	MOVZBL	EDX, npb_npofs.B[EBX]	;Point to IP header in packet
	ADDL	EDX, EBX
	PUSHL	ESI
	CALL	xosipsSetEcho##		;Set up an echo packet
	POPL	ESI
	JC	ignorex			;If error
	MOVB	tcp_code.B[EDX], #TCPC$ACK|TCPC$RST ;Indicate ACK and reset
	CLRL	EAX
	MOVL	tcp_seqnum.B[EDX], EAX
	INCL	tpdb_tcpcntnodst[ESI]	;Count the discarded packet
	ADDL	tpdb_tcpcntbyteout.B[ESI], #20t.B
newsy4:	POPL	EAX			;Get his sequence number
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	INCL	EAX			;Plus one
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_acknum.B[EDX], EAX	;Gives ACK number
	POPL	EAX			;Get port numbers
	RORL	EAX, #16t		;Reverse them
	MOVL	tcp_srcport.B[EDX], EAX
	MOVB	tcp_offset.B[EDX], #50h
	CLRL	EAX
	MOVW	tcp_window.B[EDX], AX
	MOVL	tcp_checksum.B[EDX], EAX ;(This also clears tcp_urgent)
	MOVL	npb_apcnt.B[EBX], EAX
	ADDL	npb_count.B[EBX], #20t.B
	MOVL	EAX, EDI
	MOVL	ECX, #20t
	CALL	tcpchksum2		;Calculate checksum if need to
	CALL	xosipsSendSet2##	;Set up final IP header stuff
	MOVL	ESI, pdb_sdb.B[EDI]	;Make sure have SDB offset
	MOVL	EAX, #xosnetGiveBufr##
	CALL	xossnpSendPkt##		;Send the packet and give it up
	RET
.PAGE
;Here when the new connection timer goes off - This means that no one has opened
;  the device associated with the new connection within 5 seconds

newcontimeout:
	CLRL	EAX
	MOVL	dcb_tcprxmtwake[EDI], EAX
	MOVL	EBX, dcb_tcprcvputb.B[EDI] ;Get offset of the SYN packet
	MOVL	dcb_tcprcvputb.B[EDI], EAX
	MOVZBL	EDX, npb_tpofs.B[EBX]	;Get offset of TCP header
	ADDL	EDX, EBX
	CLRL	ECX
	MOVL	ESI, dcb_ipstpdb.B[EDI]	;Get offset of TPDB
	PUSHL	EDI
	MOVL	EDI, tpdb_pdb.B[ESI]	;Get offset of PDB
	CALL	newsy2			;Send it back as a CONREJ packet
	POPL	EDI
	CALL	xostcpGiveDcb#		;Give up the DCB
	CLC				;Clear C to indicate done with wake
	RET				;  block
.PAGE
;Here with packet after we have sent the initial SYN when establishing a
;  connection (TCPS_SYNSENT) - this should be a SYN|ACK

rcvsynsent:
	CMPL	dcb_tcprcvputb.B[EDI], #0.B ;Is the pointer free?
	JNE	ignore.S		;No - ignore the packet!
	MOVL	dcb_tcprcvputb.B[EDI], EBX ;Yes - save offset of packet data
	MOVL	dcb_tcprcvputp.B[EDI], EDX
	MOVZWL	EAX, tcp_window.B[EDX]	;Get window size
	XCHGB	AL, AH
	MOVL	dcb_tcpsndwina[EDI], EAX ;Store it
	MOVL	dcb_tcpsndwinm[EDI], EAX
	LEAVE
	CLRL	EAX
	MOVL	EDX, dcb_tcpfuncdisp.B[EDI]
	JMPIL	CS:tcpf_synsent.B[EDX]

;Here with packet after we have sent the ACK for the SYN|ACK - this is either
;  the first data packet for the TCP connection or is a retransmission of the
;  SYN|ACK (which means that our ACK was lost)

rcvsynackd:
	MOVL	EAX, tcp_seqnum.B[EDX]	;Is the sequence number right?
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	CMPL	dcb_tcprcvsnum.B[EDI], EAX
	JNE	4$.S			;No - ignore the packet!
	MOVB	AL, tcp_code.B[EDX]	;Yes
	ANDB	AL, #~TCPC$PSH
	CMPB	AL, #TCPC$SYN|TCPC$ACK	;Is this a SYN|ACK?
	JE	6$.S			;Yes
	MOVB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;No - update connection state
	JMP	rcvestab		;Continue

;Here with out of sequence packet

4$:	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the out of sequence packet
	INCL	tpdb_tcpcntoutseq[EAX]
ignore:	MOVL	EBX, rcv_pkt.B[EBP]	;Make sure have packet buffer offset
	CALL	xosnetGiveBufr##	;Give up the packet buffer
	RET

;Here with retransmission of the SYN|ACK - in this case we just ACK it again

6$:	CALL	xosnetGiveBufr##	;Finished with this packet
	JMP	tcpsendacknow
.PAGE
;Here with the packet which should be the ACK for the SYN|ACK we just sent
;  - there are several posibilities here:
;	1.  ACK with correct sequence and ACK numbers
;		This completes the connection sequence
;	2.  SYN which is a duplicate of the original we received
;		This must be a retransmission caused by the loss of our
;		SYN|ACK - we send it again
;	3.  ACK with FIN indicated with correct sequence and ACK numbers
;		This is an aborted connection sequence - we return a
;		ER_NCLST error
;	4.  All other cases
;		We ignore the packet and continue waiting

rcvsynrcvd:
	MOVL	ECX, tcp_seqnum.B[EDX]
	XCHGB	CL, CH
	RORL	ECX, #16t
	XCHGB	CL, CH
	MOVB	AL, tcp_code.B[EDX]
	ANDB	AL, #~TCPC$PSH		;Ignore the PUSH bit here
	CMPB	AL, #TCPC$ACK		;Simple ACK?
	JE	8$.S			;Yes
	CMPB	AL, #TCPC$ACK|TCPC$FIN	;ACK with FIN?
	JE	8$.S			;Yes
	CMPB	AL, #TCPC$SYN		;SYN?
	JNE	2$.S			;No - ignore it
	INCL	ECX			;Yes - is it the same one?
	CMPL	ECX, dcb_tcprcvsnum.B[EDI]
	JE	4$.S			;Yes
2$:	MOVL	EAX, dcb_ipstpdb.B[EDI]	;No - count the out of sequence packet
	INCL	tpdb_tcpcntoutseq[EAX]
	JMP	ignore.S		;Ignore the packet

;Here if get the SYN again - in this case we return a no response error so
;  the XFF code will resend the SYN|ACK

4$:	MOVL	EAX, #ER_NORSP
	JMP	10$.S

;Here with ACK or ACK|FIN in response to our SYN|ACK

8$:	CMPL	ECX, dcb_tcprcvsnum.B[EDI] ;Is it the one we are expecting?
	JNE	2$.S			;No - ignore it
	MOVL	EAX, tcp_acknum.B[EDX]	;Maybe
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	DECL	EAX
	CMPL	EAX, dcb_tcpsndsnum[EDI]
	JNE	2$.S			;No
	INCL	dcb_tcpsndsnum[EDI]	;Yes - fix up the sequence numbers
	INCL	dcb_tcpsndsnext[EDI]
	INCL	dcb_tcprcvanum.B[EDI]
	TESTB	tcp_code.B[EDX], #TCPC$FIN ;FIN indicated?
	JNE	12$.S			;Yes - fail
	MOVB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;No - set new connection state
	MOVZBL	EAX, tcp_offset.B[EDX]	;Get length of TCP header
	SHRL	EAX, #2
	ANDB	AL, #0FCh
	CMPL	rcv_tcplen.B[EBP], EAX
	JA	estab2			;Go handle data if have any
	CLRL	EAX			;No data - indicate OK
10$:	CALL	xosnetGiveBufr##	;Discard the packet
	MOVL	EDX, dcb_tcpfuncdisp.B[EDI]
	JMPIL	CS:tcpf_ackrcvd.B[EDX]	;Poke the XFF

;Here if FIN indicated - fail

12$:	MOVL	EAX, #ER_NCLST
	JMP	10$.S
.PAGE
;Here with FIN|ACK packet which does not have a matching DCB - we really
;  should ignore this, but we process it to keep Suns (any probably other
;  Unix systems) from going through an extremely long FIN_WAIT_1 timeout!
;	c{EBX} = Offset of packet buffer
;	c{EDX} = Offset of TCP packet header

newfinack:
	MOVL	EDI, rcv_pdb.B[EBP]
	MOVL	EBX, rcv_pkt.B[EBP]	;Restore offset of packet buffer
	MOVL	EAX, rcv_tpdb.B[EBP]	;  wants
	INCL	tpdb_tcpcntnodst[EAX]	;Count the discarded packet
	INCL	tpdb_tcpcntunxfin[EAX]	;Count the unexpected FIN
	ADDL	tpdb_tcpcntbyteout.B[EAX], #20t.B
	LEAVE
	PUSHL	tcp_srcport.B[EDX]	;Save source and destination ports
	PUSHL	tcp_seqnum.B[EDX]	;Save sequence number
	PUSHL	tcp_acknum.B[EDX]	;Save ACK number
	MOVZBL	EDX, npb_npofs.B[EBX]	;Point to IP header in packet
	ADDL	EDX, EBX
	CALL	xosipsSetEcho##		;Set up an echo packet
	JC	ignore			;If error, forget about it!
	MOVB	tcp_code.B[EDX], #TCPC$ACK|TCPC$FIN ;Indicate ACK and FIN
	POPL	tcp_seqnum.B[EDX]	;Set sequence number to what he
	JMP	newsy4			;Continue
.PAGE
;Here with packet after we have received a FIN but before we have sent a
;  FIN in reply

rcvclosewait:
	CALL	procpkt			;Do preliminary packet processing
	JC	ret006.S		;If can not continue with packet
	JMP	ignore			;Otherwise just ignore it

;Here with packet after we have sent a reply FIN and are waiting for the
;  last ACK

rcvlastack:
	TESTB	tcp_code.B[EDX], #TCPC$SYN ;Is this a SYN packet?
	JNE	8$.S			;Yes - this must mean we lost the final
					;  ACK and he's trying to set up a new
					;  connection - we treat this just like
					;  the final ACK but otherwise ignore
					;  it - he should retransmit the SYN in
					;  a few seconds and it should all work
					;  right then!
	MOVL	EAX, tcp_seqnum.B[EDX]	;No - get sequence number from packet
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	CMPL	EAX, dcb_tcprcvsnum.B[EDI] ;Is this what we are expecting?
	JNE	10$.S			;No - ignore it
	TESTB	tcp_code.B[EDX], #TCPC$ACK|TCPC$RST ;Is this an ACK or a reset?
	JE	12$.S			;No - ignore it
2$:	MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSED ;Yes - indicate idle
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is this DCB in use?
	JE	4$.S			;No
	CALL	wakeall			;Yes - wake up anyone waiting
	CALL	xosnetGiveBufr##
	RET

;Here if DCB is not in use

4$:	PUSHL	EBX
	CALL	givedcb			;Free up the DCB
	POPL	EBX
	CALL	xosnetGiveBufr##	;Give up the packet buffer
ret006:	RET

;Here for SYN when expecting final ACK

8$:	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the out of sequence packet
	INCL	tpdb_tcpcntoutseq[EAX]
	JMP	2$.S

;Here for out of sequence packet

10$:	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the out of sequence packet
	INCL	tpdb_tcpcntoutseq[EAX]
	CALL	xosnetGiveBufr##	;Give up the packet buffer
	RET

12$:	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the packet with no ACK
	INCL	tpdb_tcpcntnoack[EAX]
	CALL	xosnetGiveBufr##	;Give up the packet buffer
	RET
.PAGE
;Here with packet when in the connected (TCPS_ESTAB) state

rcvestab:
	CALL	procpkt			;Do preliminary packet processing
	JC	ret006.S		;If can not continue with packet
	TESTB	tcp_code.B[EDX], #TCPC$FIN ;Is this a FIN?
	JNE	2$.S			;Yes
	CALL	estab0			;No - process the data
	JMP	4$.S			;Continue

;Here if have a FIN

2$:	CALL	estab0			;Process the packet first
	INCL	dcb_tcprcvsnum.B[EDI]	;Bump receive sequence number for FIN
	CALL	tcpsendacknow		;Send ACK for the FIN
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is this DCB in use?
	JE	8$.S			;No
	MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSEWAIT ;Yes - update state
	MOVL	EAX, dcb_tcpfuncdisp.B[EDI] ;Dispatch to routine for protocol
	CALLI	CS:tcpf_rcvfin.B[EAX]
4$:	MOVL	EBX, dcb_tcprcvoosl[EDI] ;Have any out-of-sequence packets?
	TESTL	EBX, EBX
	JE	10$.S			;No - finished now
	MOVL	EAX, npb_seqnum.B[EBX]	;Yes - is this the one we are expecting?
	CMPL	dcb_tcprcvsnum.B[EDI], EAX
	JNE	10$.S			;No - finished
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Yes - get offset of the TPDB
	DECL	tpdb_tcpcntoosnum.B[EAX] ;Reduce count
	MOVL	EAX, npb_next.B[EBX]	;Remove packet from the list
	MOVL	dcb_tcprcvoosl[EDI], EAX
	MOVL	rcv_pkt.B[EBP], EBX
	MOVZBL	EDX, npb_tpofs.B[EBX]
	MOVL	ECX, npb_count.B[EBX]
	SUBL	ECX, EDX
	MOVL	rcv_tcplen.B[EBP], ECX
	ADDL	EDX, EBX
	MOVL	rcv_tcphdr.B[EBP], EDX
	DECB	dcb_tcprcvoosc.B[EDI]
	JS	6$.S
	MOVZBL	EAX, dcb_tcpstate.B[EDI] ;Get connection state
	JMPIL	CS:rcvdsp[EAX*4]	;Dispatch on the state to process the
					;  packet

6$:	CRASH	OOSC			;[Out-Of-Sequence Count is bad]

;Common receive finish routine

tcprcvfin::
	MOVL	EAX, #ER_NCCLR		;Wake up anyone who might be waiting
	CALL	xosnetRspDone##
	MOVL	EAX, #ER_NCCLR
	JMP	xosnetSndDone##

;Here with FIN for DCB which is not in use - we must respond here

8$:	MOVB	dcb_tcpstate.B[EDI], #TCPS_LASTACK ;Update state
	CALL	xostcpSendFin#		;Send a FIN
	JC	givedcb			;Error - just terminate it all now
10$:	RET				;Finished if OK

;Subroutine to process the data in a packet

estab0:	MOVL	ECX, npb_apcnt.B[EBX]	;Get length of TCP data
	TESTL	ECX, ECX
	JLE	ignore			;Finished with this packet if no data
estab2:	CMPL	ECX, dcb_tcprcvwinb.B[EDI] ;Can we take this much data now?
	JBE	14$.S			;Yes
	TESTB	dcb_ipssts1.B[EDI], #IPSS1$NOMERGE ;No - are we in "funny" mode?
	JNE	16$.S			;Yes - send a "no-op" ACK
	CMPL	dcb_tcprcvwinb.B[EDI], #0.B ;No - is the window closed now?
	JE	16$.S			;Yes - send a "no-op" ACK
	MOVL	ECX, dcb_ipstpdb.B[EDI]	;No - count the flow control overrun
	INCL	tpdb_tcpcntflowovr[ECX]
	MOVL	ECX, dcb_tcprcvwinb.B[EDI] ;Accept as much as we can
14$:	ADDL	EDX, EAX		;Get offset of the data
	ADDB	AL, npb_tpofs.B[EBX]
	MOVB	npb_apofs.B[EBX], AL
	MOVL	EAX, dcb_tcpfuncdisp.B[EDI] ;Continue
	JMPIL	CS:tcpf_estab.B[EAX]

;Here if window is completely closed and we have a non-empty packet - this may
;  be a window probe, so we send back an ACK which ACKs nothing

16$:	DECL	ECX			;Does it contain 1 byte of data?
	JE	18$.S			;Yes - this is a normal window probe
	MOVL	ECX, dcb_ipstpdb.B[EDI]	;No - count the flow control overrun
	INCL	tpdb_tcpcntflowovr[ECX]
18$:	CALL	xosnetGiveBufr##	;Give up the packet
	JMP	tcpsendackf		;Send an ACK
.PAGE
;Standard input packet processing for ESTAB state for TCP

tcpestab::
	CMPL	dcb_tcprcvputb.B[EDI], #0.B ;Do we have any receive packets?
	JNE	2$.S			;Yes
	MOVL	dcb_tcprcvtakb.B[EDI], EBX ;No - just save this one
	MOVL	dcb_tcprcvtakp.B[EDI], EDX
	MOVL	dcb_tcprcvtakc.B[EDI], ECX
	MOVL	dcb_tcprcvcnt.B[EDI], ECX
	JMP	8$.S

;Here if have at least one receive packet buffered

2$:	CMPL	dcb_tcprcvavl[EDI], ECX	;Can we merge packets?
	JB	6$.S			;No - go link in this packet

	JMP	6$.S			;;;;;;;;;;;

	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Yes - get offset of the TPDB
	INCL	tpdb_tcpcntmerge.B[EAX]	;Count the merged packet
	ADDL	dcb_tcprcvcnt.B[EDI], ECX ;Advance pointers and counts
	MOVL	EAX, dcb_tcprcvputb.B[EDI]

;;;;;;;qqqqqqqqqqqqqq

	ADDL	npb_count.B[EAX], ECX
	SUBL	dcb_tcprcvavl[EDI], ECX
	MOVL	EAX, dcb_tcprcvputp.B[EDI]
	ADDL	dcb_tcprcvputp.B[EDI], ECX
	PUSHL	EDI
	PUSHL	ESI
	PUSHL	ECX
	MOVL	EDI, EAX
	PUSHL	DS
	POPL	ES
	MOVL	ESI, EDX
	CLD


	CMPL	ECX, #8.B		;More than 8 bytes to store?
	JBE	4$.S			;No


	MOVL	EAX, ECX		;Yes - get destination long alligned
	MOVL	ECX, EDI
	NEGL	ECX
	ANDL	ECX, #03h.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EAX

	SHRL	ECX, #2			;Copy longs
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, EAX
	ANDL	ECX, #03h.B
4$:	RMOVSB	[EDI], [ESI]		;Copy any bytes left over

;;;;;qqqqqq

	POPL	ECX
	POPL	ESI
	POPL	EDI
	CALL	xosnetGiveBufr##	;Give up the packet
	JMP	10$.S

;Here if cannot merge packets - link this packet to the list

6$:	MOVL	EAX, dcb_tcprcvputb.B[EDI]
	MOVL	npb_next.B[EAX], EBX
	ADDL	dcb_tcprcvcnt.B[EDI], ECX
8$:	CLRL	EAX
	MOVL	npb_next.B[EBX], EAX
	MOVL	dcb_tcprcvputb.B[EDI], EBX
	ADDL	EDX, ECX
	MOVL	dcb_tcprcvputp.B[EDI], EDX
	MOVL	npb_apcnt.B[EBX], ECX
	MOVZBL	EAX, npb_sizex.B[EBX]	;Calculate amount left in packet
	MOVL	EAX, knlXmbSize##[EAX*4]
	LEAL	EAX, -npb_mSIZE.B[EAX+EBX]
	SUBL	EAX, EDX
	MOVL	dcb_tcprcvavl[EDI], EAX
10$:	ADDL	dcb_tcprcvsnum.B[EDI], ECX ;Bump receive sequence number
	SUBL	dcb_tcprcvwinb.B[EDI], ECX ;Reduce receive window size
	CALL	xostcpSendAck		;Send ACK
	CLRL	EAX
	JMP	xosnetRspDone##
.PAGE
2$:	RET

;Here with received data packet after we have sent a FIN - get here for both
;  FINWAIT1 and FINWAIT2 states

rcvfinwait:
	CALL	procpkt			;Do preliminary packet processing
	JC	2$.S			;If can not continue with packet
	CMPL	dcb_tcpsndhead[EDI], #0.B ;Anything left unACKed?
	JNE	4$.S			;Yes
	MOVB	dcb_tcpstate.B[EDI], #TCPS_FINWAIT2 ;No - update state
4$:	MOVZBL	EAX, tcp_offset.B[EDX]	;Get length of TCP header
	SHRL	EAX, #2
	ANDB	AL, #0FCh
	SUBL	ECX, EAX		;Get length of data part
	PUSHL	tcp_code.B[EDX]		;Save code bits from the packet
	PUSHL	ECX
	CALL	xosnetGiveBufr##	;Finished with the packet
	POPL	ECX
	TESTB	[ESP], #TCPC$FIN	;Does it have FIN set?
	JE	6$.S			;No
	INCL	ECX			;Yes
6$:	TESTL	ECX, ECX		;Have any data bytes or FIN?
	JE	8$.S			;No - don't send an ACK
	ADDL	dcb_tcprcvsnum.B[EDI], ECX ;Bump receive sequence number
	CALL	tcpsendacknow		;Send ACK immediately
8$:	POPL	EAX			;Restore code bits from the packet
	TESTB	AL, #TCPC$FIN		;Was this packet a FIN?
	JE	ret012.S		;No - finished here
	CMPB	dcb_tcpstate.B[EDI], #TCPS_FINWAIT1 ;Have we received the ACK?
	MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSING ;Assume we have not
	JE	ret012.S		;Right - just wait for the ACK
timew:	MOVB	dcb_tcpstate.B[EDI], #TCPS_TIMEWAIT ;Wrong - all finished
	CMPL	dcb_opencnt.B[EDI], #0.B ;Is anyone using this DCB?
	JNE	wakeall.S		;Yes
givedcb:MOVL	EAX, dcb_sdisp.B[EDI]	;No - give up the DCB
	JMPIL	CS:sd_cleardcb.B[EAX]

wakeall:CLRL	EAX
	CALL	knlResumeInput##	;Wake him up if he's waiting for
	CLRL	EAX			;  anything
	JMP	knlResumeOutput##
.PAGE
;Here with received data packet after we have received a reply FIN without an
;  ACK - this should be the ACK for the FIN we initially sent

rcvclosing:
	CALL	procpkt			;Do preliminary packet processing
	JC	ret012.S		;If can not continue with packet
	CMPL	dcb_tcpsndhead[EDI], #0.B ;Anything left unACKed?
	JE	timew.S			;No - all finished now
ret012:	RET
.PAGE
;Subroutine to do preliminary packet processing - this subroutine processes
;  acknowlegements and window size changes
;	c{EBX} = c{rcv_pkt{EBP}}    = Offset of packet buffer
;	c{ECX} = c{rcv_tcphdr{EBP}} = Length of TCP part of the packet
;	c{EDX} = c{rcv_tcplen{EBP}} = Offset of TCP header
;	c{EDI} = Offset of DCB
;	CALL	procpkt
;	C:set = Cannot continue with packet (packet already given up)
;	C:clr = Can process data part of packet

procpkt:TESTB	tcp_code.B[EDX], #TCPC$SYN ;Is this a SYN packet?
	JNE	2$.S			;Yes - treat it like it is below the
	MOVL	EAX, tcp_seqnum.B[EDX]	;  receive window
	XCHGB	AL, AH			;No - get sequence number from packet
	RORL	EAX, #16t
	XCHGB	AL, AH
	CMPL	EAX, dcb_tcprcvsnum.B[EDI] ;Is this what we are expecting?
	JE	26$			;Yes
	JNS	8$.S			;No
2$:	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the out of window packet
	INCL	tpdb_tcpcntoutwin[EAX]
	CALL	tcpsendacknow		;Below window (or SYN) - ACK it
4$:	MOVL	EBX, rcv_pkt.B[EBP]
6$:	CALL	xosnetGiveBufr##	;But otherwise ignore it
	STC
	RET

;Here for out of sequence packet which is in the window

8$:	MOVL	npb_seqnum.B[EBX], EAX
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the out of sequence packet
	INCL	tpdb_tcpcntoutseq[EAX]
	CALL	procack			;Process the ACK in this packet
	MOVL	EBX, rcv_pkt.B[EBP]
	MOVL	EDX, rcv_tcphdr.B[EBP]
	MOVL	ECX, rcv_tcplen.B[EBP]
	MOVZBL	EAX, tcp_offset.B[EDX]	;Get length of TCP header
	SHRL	EAX, #2
	ANDL	EAX, #0FFFFFFFCh.B
	CMPL	ECX, EAX		;Do we have any data?
	JLE	6$.S			;No - discard the packet
	CMPB	dcb_tcprcvoosc.B[EDI], #10t ;Have too many now?
	JAE	6$.S			;Yes - discard the packet
	SUBL	EDX, EBX		;No
	MOVB	npb_tpofs.B[EBX], DL	;Store offset of TCP (transport) part
	SUBL	ECX, EAX
	MOVL	npb_apcnt.B[EBX], ECX
	INCB	dcb_tcprcvoosc.B[EDI]	;Count this one
	MOVL	EDX, dcb_ipstpdb.B[EDI]	;Get offset of the TPDB
	INCL	tpdb_tcpcntoosnum.B[EDX] ;Bump count
	MOVL	EAX, tpdb_tcpcntoosnum.B[EDX] ;Is this a new maximum?
	CMPL	tpdb_tcpcntoosmax.B[EDX], EAX
	JAE	10$.S			;No
	MOVL	tpdb_tcpcntoosmax.B[EDX], EAX ;Yes - remember it
10$:	MOVL	EAX, npb_seqnum.B[EBX]	 ;Scan the out-of-sequence list to
	MOVL	EDX, dcb_tcprcvoosl[EDI] ;  find the place to put this packet
	TESTL	EDX, EDX
	JE	12$.S
	CMPL	EAX, npb_seqnum.B[EDX]	;Does this one go before the first one?
	JE	6$.S
	JA	14$.S			;No
12$:	MOVL	dcb_tcprcvoosl[EDI], EBX ;Yes - link it in
	MOVL	npb_next.B[EBX], EDX	
	JMP	20$.S			;Continue	

;Here if this packet does not go before the first packet in the out-of-sequence
;  list

14$:	MOVL	ECX, EDX		;Advance to next packet in list
	MOVL	EDX, npb_next.B[EDX]
	TESTL	EDX, EDX		;Have another?
	JE	16$.S			;No
	CMPL	EAX, npb_seqnum.B[EDX]	;Yes - does this one go here?
	JE	6$
	JA	14$.S			;No - continue
16$:	MOVL	npb_next.B[ECX], EBX	;Yes - link it in
	MOVL	npb_next.B[EBX], EDX
	MOVL	EBX, ECX
	CALL	chkmrg			;See if can merge with previous packet
	JC	24$.S			;Finished if could merge (in this case
					;  we know we cannot merge any more so
					;  there is no point in checking more)
18$:	MOVL	EBX, npb_next.B[EBX]	;Advance to next packet
	TESTL	EBX, EBX		;Finished if no next packet
	JE	22$.S
20$:	CALL	chkmrg			;See if can merge here
	JC	18$.S			;Continue checking if could merge
22$:	STC
24$:	RET

;Here with the expected packet

26$:	TESTB	tcp_code.B[EDX], #TCPC$RST ;Is this a reset?
	JNE	resetp			;Yes - go handle it
	TESTB	tcp_code.B[EDX], #TCPC$ACK ;No - does this packet contain an
					   ;  acknowledgement?
	JE	6$			;No - ignore this packet!
	CALL	procack			;Yes - process the ACK
	MOVL	EBX, dcb_tcpsndhead[EDI] ;Make sure the sequence number are
	TESTL	EBX, EBX		  ;  right (DEBUG ONLY)
	JE	28$.S
	MOVL	EAX, npb_seqnum.B[EBX]
	CMPL	dcb_tcprcvanum.B[EDI], EAX
	JNE	30$.S
28$:	MOVL	EBX, rcv_pkt.B[EBP]	;Restore registers
	MOVL	EDX, rcv_tcphdr.B[EBP]
	MOVL	ECX, rcv_tcplen.B[EBP]
	CLC				;Indicate still have packet
	RET

30$:	CRASH	SEQ2
.PAGE
2$:	CLC
	RET

;Subroutine to  merge two out-of-sequence packets if possible
;	c{EBX} = Offset of first packet buffer (must be in the out-of-sequence
;		   packet list
;	CALL	chkmrg
;	C:set = Packets were merged
;	C:clr = Could not merge packets

chkmrg:	CLC
	RET

	MOVL	ECX, npb_next.B[EBX]	;Get offset of next packet
	JREGZ	ECX, 2$			;Return with C clear if no next packet
	MOVZBL	EDX, npb_tpofs.B[ECX]	;Does the second packet contain urgent
	ADDL	EDX, ECX		;  data?
	CMPW	tcp_urgent.B[EDX], #0.B
	JNE	2$.S			;Yes - can't merge
	MOVL	EAX, npb_seqnum.B[EBX]	;Are the packets adjacent?
	ADDL	EAX, npb_apcnt.B[EBX]
	CMPL	EAX, npb_seqnum.B[ECX]
	JNE	2$.S			;No - can't merge
	MOVZBL	EDX, npb_sizex.B[EBX]	 ;Yes - get actual space available in
	MOVL	EAX, knlXmbSize##[EDX*4] ;  the first packet
	SUBL	EAX, #npb_mSIZE.B
	MOVB	DL, npb_tpofs.B[EBX]
	SUBL	EAX, EDX
	SUBL	EAX, npb_apcnt.B[EBX]
	CMPL	npb_apcnt.B[ECX], EAX	;Will this second one fit?
	JA	2$.S			;No - can't merge
	MOVL	EAX, npb_next.B[ECX]	;Yes - unlink the second packet
	MOVL	npb_next.B[EBX], EAX
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Get offset of the TPDB
	DECL	tpdb_tcpcntoosnum.B[EAX] ;Reduce the count
	DECB	dcb_tcprcvoosc.B[EDI]
	JS	6$.S
	PUSHL	ECX
	PUSHL	EDI			;Merge the packets
	PUSHL	ESI
	MOVZBL	EDI, npb_tpofs.B[EBX]
	ADDL	EDI, EBX
	MOVZBL	EAX, tcp_offset.B[EDI]
	SHRL	EAX, #2
	ADDL	EDI, EAX
	ADDL	EDI, npb_apcnt.B[EBX]
	PUSHL	DS
	POPL	ES
	MOVZBL	ESI, npb_tpofs.B[ECX]
	ADDL	ESI, ECX
	MOVZBL	EAX, tcp_offset.B[ESI]
	SHRL	EAX, #2
	ADDL	ESI, EAX
	MOVL	ECX, npb_apcnt.B[ECX]
	ADDL	npb_apcnt.B[EBX], ECX

;;;;;;;qqqqqqqqqqqqq

	ADDL	npb_count.B[EBX], ECX
	CLD
	CMPL	ECX, #8.B		;More than 8 bytes to store?
	JBE	4$.S			;No
	MOVL	EAX, ECX		;Yes - get destination long alligned
	MOVL	ECX, EDI
	NEGL	ECX
	ANDL	ECX, #03h.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2			;Copy longs
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, EAX
	ANDL	ECX, #03h.B
4$:	RMOVSB	[EDI], [ESI]		;Copy any bytes left over
	POPL	ESI
	POPL	EDI
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the merged packet
	INCL	tpdb_tcpcntoosmrgd.B[EAX]
	XCHGL	EBX, [ESP]
	CALL	xosnetGiveBufr##	;Give up the second packet
	POPL	EBX
	STC				;Indicate packets were merged
	RET

6$:	CRASH	OOSC
.PAGE
;Here if have a reset packet

resetp:	CALL	xosnetGiveBufr##	;Finished with the packet
	CALL	xostcpGiveAll		;Give up all buffers and other stuff
	CALL	xostcpHashClr		;Remove DCB from the hash table
	MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSED ;Indicate idle
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the reset
	INCL	tpdb_tcpcntrstrcvd[EAX]
	MOVL	EAX, #ER_NCLST
	CALL	knlResumeInput##	;Wake him up if he's waiting for
	MOVL	EAX, #ER_NCLST		;  anything
	CALL	knlResumeOutput##
	STC				;Indicate no packet to process
	RET				;Return
.PAGE
;Subroutine to process the ACK in a received packet
;	CALL	procack

procack:MOVL	EAX, tcp_acknum.B[EDX]	;Get ACK number
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	CMPL	dcb_tcpsndsnext[EDI], EAX ;Greater than we have sent?
	JS	2$.S			;Yes - ignore the ACK
	CMPL	EAX, dcb_tcprcvanum.B[EDI] ;No - greater than last ACK?
2$:	JS	ackdone			;No
	MOVL	dcb_tcprcvanum.B[EDI], EAX ;Yes - update last ACK number
4$:	MOVL	EBX, dcb_tcpsndhead[EDI] ;Have anything on the send list?
	TESTL	EBX, EBX
	JE	ackdone			;No - go on
	MOVL	ECX, EAX		;Yes
	SUBL	ECX, npb_seqnum.B[EBX]	;Get number of bytes ACKed after this
	JE	ackdone			;If no more ACKed
	JS	ackdone
	ORB	dcb_tcpsts1.B[EDI], #TCPS1$ACKED ;Indicate something was ACKed
	CMPL	ECX, npb_apcnt.B[EBX]	;Is the packet completely ACKed?
	JB	ackpart			;No
	MOVL	ECX, npb_next.B[EBX]	;Yes - remove packet from the list
	MOVL	dcb_tcpsndhead[EDI], ECX
	TESTL	ECX, ECX
	JNE	6$.S
	MOVL	dcb_tcpsndtail[EDI], ECX
6$:	TESTB	npb_sts.B[EBX], #NPS$REXMITD ;Was this packet retransmitted?
	JNE	24$			;Yes - don't calculate round-trip time
	CMPL	dcb_tcprxmtbgn[EDI], #0.B ;No - do we have a time to use?
	JE	24$			;No
	PUSHL	EAX			;Yes
	MOVL	EAX, knlTickTtl##	;Get round-trip time for packet
	SUBL	EAX, dcb_tcprxmtbgn[EDI]
	MOVL	dcb_tcprxmtbgn[EDI], #0
	JG	8$.S			;Make sure its at least 1!
	MOVL	EAX, #1t
8$:
.IF NE $$TCPTIME
	MOVL	tcptimetemp, EAX
.ENDC

;Here with the round-trip time for the packet - now calculate the error value:
;	error = time - average
;  Note that the average (dcb_tcprxmtave) is scaled by 8 here.

	SHLL	EAX, #3t
	SUBL	EAX, dcb_tcprxmtave[EDI] ;Calculate error value

;Now update the average using the error value (note that we use an unbalanced
;  weighting factor - 1/8 if decreasing and 1/2 if increasing)

	JNS	10$.S			;If increasing, use t = 2, if decreasing
;;;;;;;	SARL	EAX, #2t		;  use t = 8
10$:	SARL	EAX, #1t
	ADDL	dcb_tcprxmtave[EDI], EAX ;Update average
	CMPL	dcb_tcprxmtave[EDI], #{TIMEOUT_TRNMAX/FDPERTICK}*12t ;Too big?
	JBE	12$.S			;No
	MOVL	dcb_tcprxmtave[EDI], #{TIMEOUT_TRNMAX/FDPERTICK}*12t ;Yes

;Now calculate the new variance (change in the error value).  Note that the
;  average variance value (dcb_tcprxmtvar) is scaled by 4 here.

12$:	TESTL	EAX, EAX		;Get magnatude of the error value
	JNS	14$.S
	NEGL	EAX
14$:	SHLL	EAX, #2t
	SUBL	EAX, dcb_tcprxmtvar[EDI]
	SARL	EAX, #2t
	ADDL	dcb_tcprxmtvar[EDI], EAX ;Update the average variance value
	CMPL	dcb_tcprxmtvar[EDI], #{TIMEOUT_TRNMAX/FDPERTICK}*4t ;Too big?
	JBE	16$.S			;No
	MOVL	dcb_tcprxmtvar[EDI], #{TIMEOUT_TRNMAX/FDPERTICK}*4t ;Yes

;Now calculate the retranmission time-out value.  This is
;	timeout = 2 * (average + variance) + 10
;  Note that the average is scaled by 8 and the variance is scaled by 4 here.
;  The extra additive term is used in place of a test for a minimum value.

16$:	MOVL	EAX, dcb_tcprxmtave[EDI]
	SHRL	EAX, #1
	CMPL	dcb_tcprxmtvar[EDI], EAX ;Is the variance too big?
	JBE	18$.S			;No - go on
	MOVL	dcb_tcprxmtvar[EDI], EAX ;Yes - reduce it
18$:	ADDL	EAX, dcb_tcprxmtvar[EDI]
	SHRL	EAX, #1
	ADDL	EAX, #10t.B
	CMPL	EAX, #TIMEOUT_TRNMAX/FDPERTICK ;Too big?
	JB	20$.S			;No
	MOVL	EAX, #TIMEOUT_TRNMAX/FDPERTICK ;Yes - just use the maximum
	MOVL	dcb_tcprxmtave[EDI], #{TIMEOUT_TRNMAX/FDPERTICK}*2
	MOVL	dcb_tcprxmtvar[EDI], #0
20$:	MOVL	dcb_tcprxmtint[EDI], EAX ;Update retransmition interval value

.IF NE $$TCPTIME
	PUSHL	EDX
	MOVL	EDX, tcptimepnt
	MOVL	EAX, tcptimetemp
	MOVW	[EDX], AX
	MOVL	EAX, npb_count.B[EBX]
	MOVW	2.B[EDX], AX
	MOVL	EAX, dcb_tcprxmtint[EDI]
	MOVL	4.B[EDX], EAX
	MOVL	EAX, dcb_tcprxmtave[EDI]
	ADDL	EAX, EAX
	MOVL	8t.B[EDX], EAX
	MOVL	EAX, dcb_tcprxmtvar[EDI]
	SHLL	EAX, #2t
	MOVL	12t.B[EDX], EAX
	ADDL	EDX, #16t.B
	CMPL	EDX, #tcptimeend
	JB	22$.S
	MOVL	EDX, #tcptimering
22$:	MOVL	tcptimepnt, EDX
	POPL	EDX
.ENDC
	POPL	EAX
24$:	TESTB	npb_sts.B[EBX], #NPS$OVRCMTD ;Was this packet overcommitted?
	JE	26$.S			;No
	ANDB	npb_sts.B[EBX], #~NPS$OVRCMTD
	DECL	dcb_tcpsndover[EDI]	;Yes - possible if this was a window
					;  probe which has been accepted
	JS	30$.S
26$:	CALL	xosnetGiveBufr##	;Give up the packet buffer
	JMP	4$

30$:	CRASH	BOVR
.PAGE
;Here with packet buffer which has been partially ACKed
;	c{ECX} = Number of bytes ACKed

ackpart:CMPL	npb_nextsnd.B[EBX], #-1.B ;Is the packet being output now?
	JNE	2$.S			;Yes - must do this the hard way!
	CMPL	npb_link.B[EBX], #0.B	;No - is the buffer fragmented?
	JNE	2$.S			;Yes - another reason to copy it

;Here if we can reduce this packet in place.

	PUSHL	ESI			;Save regsiters we need to use
	PUSHL	EDI
	SUBL	npb_apcnt.B[EBX], ECX	;Reduce packet size
	SUBL	npb_count.B[EBX], ECX
	ADDL	npb_seqnum.B[EBX], ECX	;Adjust sequence number
	MOVL	EAX, npb_seqnum.B[EBX]
	XCHGB	AL, AH			;Reverse the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVZBL	EDI, npb_tpofs.B[EBX]	;Get offset of the TCP header
	MOVL	tcp_seqnum.B[EBX+EDI], EAX ;Store it in the packet in network
					   ;  byte order
	MOVZBL	EDI, npb_apofs.B[EBX]	;Get offset of start of TCP data
	ADDL	EDI, EBX
	LEAL	ESI, [EDI+ECX]		;Get offset of first byte to move
	MOVL	ECX, npb_apcnt.B[EBX]	;Get amount to move
	PUSHL	DS
	POPL	ES
	CLD
	RMOVSB	[EDI], [ESI]		;Move the data
	POPL	EDI			;Restore registers
	POPL	ESI
	JMP	ackdone

;Here if packet which we need to reduce is currently being output or if the
;  packet buffer is fragmented.  We handle these cases by allocating a new
;  packet buffer and copying the remaining data to it and then giving up the
;  old buffer.

2$:	CMPL	npb_holdrt.B[EBX], #0.B	;Is this packet being held for routing?
	JNE	20$			;Yes - don't try to ACK it now (This
					;  should not be possible, but we check
	MOVZBL	EAX, npb_apofs.B[EBX]	;  here to be safe!)
	ADDL	EAX, npb_apcnt.B[EBX]	;No - get size of the packet minus the
	SUBL	EAX, ECX		;  amount ACKed
	PUSHL	ECX
	PUSHL	EBX
	MOVL	ECX, EAX		;Get another buffer that will hold what
	CALL	xosnetGetBufr##		;  is left
	POPL	EDX
	POPL	ECX
	JC	20$			;If error
	PUSHL	ECX			;OK - save amount ACKed
	ADDL	ECX, npb_seqnum.B[EDX]	;Adjust sequence number
	MOVL	npb_seqnum.B[EBX], ECX
	XCHGB	CL, CH			;Reverse the byte order
	RORL	ECX, #16t
	XCHGB	CL, CH
	MOVZBL	EAX, npb_tpofs.B[EDX]	;Get offset of the TCP header
	MOVL	tcp_seqnum.B[EDX+EAX], ECX ;Store sequence number in the packet
	POPL	EAX			;Restore amount ACKed
	MOVL	ECX, npb_lpofs.B[EDX]	;Note: this copies npb_lpofs, npb_npofs,
	MOVL	npb_lpofs.B[EBX], ECX	;  npb_tpofs, and npb_apofs
	MOVB	CL, npb_sts.B[EDX]
	MOVB	npb_sts.B[EBX], CL
	ANDB	npb_sts.B[EDX], #~NPS$OVRCMTD
	MOVL	npb_dcb.B[EBX], EDI
	MOVL	dcb_tcpsndhead[EDI], EBX ;Put the new packet in the send list
	MOVL	ECX, npb_next.B[EDX]	  ;  in place of the old one (we know
	MOVL	npb_next.B[EBX], ECX	  ;  this was the first packet)
	TESTL	ECX, ECX		;Only packet in list?
	JNE	4$.S			;No
	MOVL	dcb_tcpsndtail[EDI], EBX ;Yes - update tail pointer too
4$:	PUSHL	ESI
	PUSHL	EDI
	MOVL	ESI, EDX		;First copy packet the headers (which
	MOVL	EDI, EBX		;  will always be completely in the
	PUSHL	DS			;  first chunk if the buffer is
	POPL	ES			;  fragmented)
	MOVZBL	ECX, npb_apofs.B[EDX]
	CLD
	RMOVSB	[EDI], [ESI]
	MOVL	ECX, npb_apcnt.B[EDX]	;Get number of data bytes to copy
	SUBL	ECX, EAX
	MOVL	npb_apcnt.B[EBX], ECX
	MOVZBL	ESI, npb_apofs.B[EDX]	;Get offset in packet of first byte to
	MOVL	npb_count.B[EBX], ECX
	ADDL	npb_count.B[EBX], ESI
	ADDL	ESI, EAX		;  copy
	MOVL	EAX, ECX

;When get here:
;	c{EAX} = Number of bytes to copy
;	c{EBX} = Offset of new packet buffer
;	c{EDX} = Offset of original packet buffer
;	c{EDI} = Destination offset
;	c{ESI} = Offset from start of packet of first byte to copy

	MOVL	EBX, EDX		;Save offset of the original buffer
	MOVZBL	ECX, npb_sizex.B[EBX]	;Get size of the first chunk
	MOVL	ECX, knlXmbSize##[ECX*4]
	SUBL	ECX, #npb_mSIZE.B	;Get number of data bytes in first chunk
6$:	CMPL	ESI, ECX		;Are we starting in this chunk?
	JB	8$.S			;Yes
	SUBL	ESI, ECX		;No - advance to next chunk
	MOVL	EDX, npc_link.B[EDX]
	MOVZBL	ECX, npc_sizex.B[EDX]	;Get size of the chunk
	MOVL	ECX, knlXmbSize##[ECX*4]
	SUBL	ECX, #npc_mSIZE.B	;Don't include the header
	JMP	6$.S			;Continue

;Here with position at which to start copy
;	c{EAX} = Total number of bytes to copy
;	c{ECX} = Size of chunk
;	c{EDX} = Offset of start of chunk
;	c{EDI} = Destination offset
;	c{ESI} = Starting offset relative to start of chunk

8$:	SUBL	ECX, ESI		;Get number of bytes available here
	ADDL	ESI, EDX
10$:	CMPL	ECX, EAX		;More than we want?
	JBE	12$.S			;No
	MOVL	ECX, EAX		;Yes
12$:	SUBL	EAX, ECX		;Reduce amount remaining
	RMOVSB	[EDI], [ESI]		;Copy the data bytes
	TESTL	EAX, EAX		;Finished?
	JE	14$.S			;Yes
	MOVL	EDX, npc_link.B[EDX]	;No - advance to next chunk
	MOVZBL	ECX, npc_sizex.B[EDX]	;Get size of the chunk
	MOVL	ECX, knlXmbSize##[ECX*4]
	SUBL	ECX, #npc_mSIZE.B	;Don't include header
	MOVL	ESI, EDX		;Update source offset
	JMP	10$.S			;Continue

;Here when finished copying the data to the new packet

14$:	POPL	EDI			;Restore pointers
	POPL	ESI
	CALL	xosnetGiveBufr##	;Give up the original packet buffer
	JMP	ackdone.S		;Continue

;Here if error allocating a packet buffer for the copy - we just forget it
;  and let him ACK it again

20$:	SUBL	dcb_tcprcvanum[EDI], EAX ;Adjust the received ACK number
					;Fall into ackdone on next page
.PAGE
;Here when finished processing ACKs

ackdone:MOVL	EBX, dcb_tcpsndhead[EDI] ;Have anything in the held list?
	TESTL	EBX, EBX
	JE	2$.S			;No - go on
	MOVL	EAX, npb_seqnum.B[EBX]	;Yes - get first sequence number
	CMPL	dcb_tcprcvanum.B[EDI], EAX ;It must be what was last ACKed!
	JNE	10$.S
	CMPL	dcb_tcpsndsnum[EDI], EAX ;Compare to what we think we sent
	JNS	2$.S			;If we know about this
	MOVL	dcb_tcpsndsnum[EDI], EAX ;Something was ACKed we we didn't
					 ;  think we had sent (like a window
					 ;  probe) - update the value
2$:	MOVL	EDX, rcv_tcphdr.B[EBP]	;Restore offset of the TCP header in
	MOVZWL	EAX, tcp_window.B[EDX]	;  the received packet
	XCHGB	AL, AH			;Get window value from the packet
	CMPL	dcb_tcpsndwinm[EDI], EAX ;New maximum window size?
	JGE	4$.S			;No
	MOVL	dcb_tcpsndwinm[EDI], EAX ;Yes - remember it
4$:	ADDL	EAX, dcb_tcprcvanum.B[EDI] ;Adjust for unACKed packets (packets
	SUBL	EAX, dcb_tcpsndsnum[EDI]   ;  on the held list)
	JNS	6$.S
	CLRL	EAX
6$:	CMPL	dcb_tcpsndwina[EDI], EAX ;Has the window changed?
	JE	ret020.S		;No
	ORB	dcb_tcpsts1.B[EDI], #TCPS1$OPENED ;Yes - indicate that
	MOVL	dcb_tcpsndwina[EDI], EAX ;Store updated window size
ret020:	RET				;Finished here

10$:	CRASH	SEQ4
.PAGE
	.SBTTL	xostcpSendAck - Subroutine to send ACK packet

;Subroutine to send ACK packet
;	CALL	xostcpSendAck

xostcpSendAck::
	MOVL	EAX, dcb_tcprcvsnum.B[EDI] ;Do we really need an ACK now?
	CMPL	dcb_tcprcvtnum.B[EDI], EAX
	JE	2$.S			;No
tcpsendackf:				;Yes
	CMPL	dcb_tcpackwake[EDI], #0.B ;Is the ACK timer running now?
	JNE	2$.S			;Yes - nothing needed now
	MOVL	EBX, #6$		;No - start the timer
	MOVL	EAX, #TIMEOUT_ACK/FDPERTICK
	PUSHL	ESI
	CALL	knlWakeRequest##
	JC	4$.S			;If error starting timer
	MOVL	dcb_tcpackwake[EDI], ESI ;OK - finished for now
	POPL	ESI
2$:	RET

;Here if can't enter timer request - just send the ACK now

4$:	POPL	ESI
	JMP	tcpsendacknow.S

;Here when the ACK timer runs out

6$:	CLRL	EAX
	MOVL	dcb_tcpackwake[EDI], EAX
	CALL	tcpsendacknow
	CLC
	RET

tcpsendacknow:
	MOVL	ECX, #60t
	CALL	xosnetGetBufr##		;Get a network buffer
	JC	2$.S			;Forget it if can't get one
tcpsendack2::
	CALL	tcpsetpkt		;Set up the packet header
	JNC	8$.S
	CALL	xosnetGiveBufr##
	RET

8$:	MOVZBL	ECX, npb_tpofs.B[EBX]
	MOVL	EAX, dcb_tcpsndsnum[EDI]
	MOVL	npb_seqnum.B[EBX], EAX
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_seqnum.B[EBX+ECX], EAX
	CALL	tcpsetack		;Store ACK number and window size in
	CALL	xosipsSendSetup##	;  packet
	MOVL	ESI, dcb_netsdb.B[EDI]
	MOVL	EAX, #xosnetGiveBufr##
	CALL	xossnpSendPkt##		;Send the packet and then give it up
	RET
.PAGE
	.SBTTL	tcpsetpkt - Subroutine to set up the TCP packet header

;Subroutine to set up the TCP (and lower) level packet headers
;	c{EBX} = Offset of packet buffer
;	CALL	tcpsetpkt
;	C:set = Error code
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c(AL)  = Value stored in npb_apofs
;	  c{EDX} = Offset of first byte after TCP header
;  EBX is respected

tcpsetpkt::
	CLRL	EAX			;Yes
	MOVL	EDX, #IPP_TCP<8t	;Get transport protocol type
	CALL	xosipsSetPkt##		;Set up IP (and lower) level headers
	JC	4$.S			;If error
	MOVL	EAX, dcb_ipslclport.B[EDI] ;Get port numbers
	XCHGB	AL, AH
	MOVL	tcp_srcport.B[EDX], EAX ;Store in packet
	CLRL	EAX
	MOVL	tcp_acknum.B[EDX], EAX	;Clear remaining fields
	MOVL	tcp_checksum.B[EDX], EAX
	MOVL	npb_apcnt.B[EBX], EAX
	MOVB	AL, #50h		;Set offset field
	MOVL	tcp_offset.B[EDX], EAX
	MOVB	AL, npb_tpofs.B[EBX]
	ADDB	AL, #tcp_options
	MOVB	npb_apofs.B[EBX], AL
	ADDL	npb_count.B[EBX], #tcp_options.B ;Update byte counts
	ADDL	EDX, #tcp_options.B	;Point to start of data area (since we
					;  don't generate options in this
4$:	RET				;  version!)
.PAGE
	.SBTTL	xostcpHashSet - Subroutine to place DCB in the TCP hash table

;Subroutine to place DCB in the IP hash table
;	c{EBX} = Hash index
;	c{EDI} = Offset of DCB
;	CALL	xostcpHashSet

xostcpHashSet::
	CMPL	dcb_ipshashnext[EDI], #-1.B
	JNE	4$.S
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	MOVL	EAX, tpdb_tcprcvhash.B[EAX]
	PUSHL	[EAX+EBX*4]
	POPL	dcb_ipshashnext[EDI]
	MOVL	[EAX+EBX*4], EDI
	RET

4$:	CRASH	IPHE			;[IP Hash Error]
.PAGE
	.SBTTL	xostcpHashClr - Subroutine to remove DCB from the TCP hash table

;Subroutine to remove DCB from the TCP hash table
;	c{EDI} = Offset of DCB
;	CALL	xostcpHashClr

xostcpHashClr:
	CMPL	dcb_ipshashnext[EDI], #-1.B ;Still in the hash table?
	JE	ret026.S		;No - nothing needed here
	CALL	tcpcalhash		;Yes - remove DCB from the hash table
	MOVL	EAX, dcb_ipstpdb.B[EDI]
	MOVL	EAX, tpdb_tcprcvhash[EAX]	   ;Get address of hash table
	LEAL	EBX, -dcb_ipshashnext.B[EAX+EBX*4] ;  entry minus off of link
						   ;  in the DCB
2$:	CMPL	dcb_ipshashnext.B[EBX], EDI ;Is it the next one?
	JE	6$.S			;Yes
	MOVL	EBX, dcb_ipshashnext.B[EBX] ;No - advance to next
	TESTL	EBX, EBX		;Have another one to check?
	JNE	2$.S			;Yes - continue
	CRASH	BNHL			;[Bad Network Hash List]

4$:	CRASH	NIHL			;[Not In Hash List]

;Here with our DCB

6$:	PUSHL	dcb_ipshashnext.B[EDI]	;Remove from list
	POPL	dcb_ipshashnext.B[EBX]
	MOVL	dcb_ipshashnext.B[EDI], #-1
	RET

	.SBTTL	tcpcalhash - Subroutine to calculate TCP hash index from DCB

;Subroutine to calculate TCP hash index from DCB
;	c{EDI} = Offset of DCB
;	CALL	tcpcalhash
;	c{EBX} = Hash index

tcpcalhash::
	PUSHL	ESI
	CLRL	EBX
	MOVL	ECX, #8			;Number of bytes to use
	LEAL	ESI, dcb_ipsrmtaddr.B[EDI] ;First byte to use
	CLD
10$:	LODSB	[ESI]			  ;  order
	ROLB	BL, #1
	XORB	BL, AL
	LOOP	ECX, 10$
	POPL	ESI
ret026:	RET
.PAGE
	.SBTTL	xostcpChkWin - Subroutine to wait until window is open

;Subroutine to wait until window is open
;	c{EAX} = Time-out value (fractional days)
;	c{EDI} = Offset of DCB
;	CALL	xostcpChkWin
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xostcpChkWin::
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;Do we have a connection?
	JNE	2$.S			;No - fail
	CMPL	dcb_tcpsndover[EDI], #0	;Do we have any overcommitted packets?
	JE	ret026.S		;No - don't need to wait
	PUSHL	EAX			;Yes - save time-out value
	CALL	xosnetSndWait##		;Wait for a while
	JC	6$.S			;If error
	POPL	EAX			;OK - restore time-out value
	JMP	xostcpChkWin.S		;Go check again

;Here if do not have a connection

2$:	MOVL	EAX, #ER_NCLST		;Assume have had fatal error
	TESTB	dcb_tcpsts1.B[EDI], #TCPS1$FATAL ;Right?
	JNE	4$.S			;Yes
	MOVB	AL, #ER_NCCLR&0FFh	;No - return right error code
4$:	STC
	RET

;Here if error while waiting

6$:	ADDL	ESP, #4.B		;Discard time-out value
	JMP	xostcpFatal
.PAGE
	.SBTTL	xostcpAlloc - Subroutine to allocate TCP packet data space

;Subroutine to allocate TCP packet data space - this subroutine serves two
;  purposes:
;	1. Ensures that a packet is allocated with at least 1 byte of free
;	   physically allocated buffer space.
;	2. Provides advice for additional allocation when a packet is to be
;	   filled by multiple calls to the tcpputxxx routines.

;  Note that the tcpputxxx routines will allocate packets as needed, even if
;  this subroutine is not called first.  Since the tcpputxxx routines have no
;  information about the total size of the packet being built, letting them
;  do their own allocation can lead to excessive packet fragmentation.  It is
;  generally a good idea to call tcpAlloc first to ensure that the packet
;  will be allocated in a single buffer before filling the packet.  If the
;  final size is not know initially, tcpchkspace can be used to extend the
;  allocation as efficiently as possible.  Note that because of the 2^N
;  ganularity of buffer allocation, doing partial allocations may actually
;  use less space.  It does result in more processing overhead, however, and
;  should be avoided when possible.

;  If there is a current output packet and the amount requested will fit in
;  that packet, a new packet is not allocated, but the amount needed is
;  remembered so that when the packet needs to be extended it will not be
;  fragmented more than is necessary.  If the amount requested will not fit
;  in the current output packet, that packet is output and a new packet is
;  allocated in a buffer big enough to hold the requested amount.  Any excess
;  amount is saved and used when making future default allocations in the
;  tcpputxxx routines.

;  The subroutine should NOT be called requesting more than will be output
;  before an explicit push, since this will waste buffer space.  An explicit
;  push clears any pending requested allocation.

;  WARNING: This subroutine DOES NOT ensure that the requested amount is
;  actually allocated!  If a buffer is currently allocated which is less than
;  the maximum packet size and the amount allocated does not fit in that
;  buffer, the additional space needed is NOT allocated here.  It is the
;  responsibility of the routine which acutually stores data in the packet to
;  ensure that space is really allocated and to add additional buffer chunks
;  to the packet if necessary!  The tcpputxxx routines do this correctly.

;	c{ECX} = Space needed
;	c{EDI} = Offset of DCB
;	CALL	xostcpAlloc
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tcpclst:MOVL	EAX, #ER_NCLST		;Report the lost connection
	STC
2$:	RET

xostcpAlloc:
	CMPL	dcb_ipsrmtaddr.B[EDI], #0.B ;Still have a connection?
	JE	tcpclst.S		;No - fail immediately
	TESTL	ECX, ECX		;Requesting 0?
	JNE	4$.S			;No
	INCL	ECX			;Yes - make it 1
4$:	CMPL	ECX, dcb_tcpsndaloc[EDI] ;Will the amount requested fit in the
					 ;  current packet?
	JBE	10$			;Yes
	PUSHL	ECX			;No
	CALL	tcppushu		;Output the current packet
6$:	POPL	ECX
	JC	2$.S			;If error
	PUSHL	ECX			;Get total amount needed
	ADDL	ECX, #ip_options+tcp_options.B
	MOVL	ESI, dcb_netpdb.B[EDI]
	CMPL	ECX, pdb_ipmaxpktsz[ESI] ;Is this too much?
	JBE	8$.S			;No
	MOVL	ECX, pdb_ipmaxpktsz[ESI] ;Yes - just ask for as much as we
8$:	ADDL	ECX, pdb_iphdrsz[ESI]	 ;  can use
	CALL	xosnetGetBufr##		;Allocate a buffer
	JC	6$.S			;If error
	MOVL	dcb_tcpsndpktb[EDI], EBX
	MOVL	dcb_tcpsndpktc[EDI], EBX
	CALL	tcpsetpkt		;Set up the packet header
	POPL	ECX
	JC	12$.S			;If error
	MOVL	dcb_tcpsndpktp[EDI], EDX
	MOVZBL	EAX, npb_sizex.B[EBX]	;Calculate available space
	MOVL	EAX, knlXmbSize##[EAX*4]
	LEAL	EAX, -npb_mSIZE.B[EAX+EBX]
	SUBL	EAX, EDX
	MOVL	dcb_tcpsndavl[EDI], EAX
	MOVL	EDX, dcb_netsdb.B[EDI]	 ;Calculate how much more we can put in
	MOVL	EAX, sdb_maxpktsz.B[EDX] ;  this packet
	SUBL	EAX, #40t.B
	SUBL	EAX, npb_count.B[EBX]
	JNS	9$.S
	CLRL	EAX
9$:	MOVL	dcb_tcpsndaloc[EDI], EAX
	CMPL	dcb_tcpsndavl[EDI], EAX	;Too much in this chunk?
	JLE	10$.S			;No
	MOVL	dcb_tcpsndavl[EDI], EAX	;Yes - fix up the value
10$:	CMPL	dcb_tcpsndavl[EDI], #0.B ;Is the current chunk full?
	JNE	14$.S			;No
	PUSHL	ECX
	CALL	tcpchkspace2		;Yes - allocate another chunk
	POPL	ECX
12$:	JC	curperr			;If error

;Here with at least one byte available in the current chunk

14$:	SUBL	ECX, dcb_tcpsndavl[EDI]	;See how much we need later
	JNS	16$.S
	CLRL	ECX			;If none
16$:	MOVL	dcb_tcpsndneed[EDI], ECX ;Store for later allocation
ret028:	RET				;Finished
.PAGE
	.SBTTL	xostcpPutLong - Subroutine to store long into a TCP packet

;Subroutine to long into a TCP packet
;	c{EAX}  = Long to store
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpPutLong
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xostcpPutLong::
	RORL	EAX, #16t		;Store high word
	CALL	xostcpPutWord
	JC	ret028.S
	SHRL	EAX, #16t		;Restore low word and fall into
					;  tcpPutWord on next page
.PAGE
	.SBTTL	xostcpPutWord - Subroutine to store word into a TCP packet

;Subroutine to word into a TCP packet
;	c[AX]  = Word to store
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpPutWord
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xostcpPutWord::
	XCHGB	AL, AH			;Store high byte
	CALL	xostcpPutByte
	JC	ret028.S
	MOVB	AL, AH			;Restore low byte and fall into
					;  tcpPutByte on next page
.PAGE
	.SBTTL	xostcpPutByte - Subroutine to store byte into a TCP packet

;Subroutine to byte into a TCP packet
;	c(AL)  = Byte to store
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpPutByte

xostcpPutByte::
	PUSHL	EAX			;Save the data byte
	MOVL	ECX, #1			;Ensure have space for at least 1 byte
	CALL	tcpchkspace
	JC	4$.S			;If error
	POPL	EAX			;Restore data
	MOVL	EDX, dcb_tcpsndpktp[EDI] ;Get pointer to place to put data
	INCL	dcb_tcpsndpktp[EDI]	;Increment the pointer
	MOVB	[EDX], AL		;Store the data
	MOVL	EBX, dcb_tcpsndpktb[EDI]
	INCL	npb_count.B[EBX]	;Adjust the counts
	INCL	npb_apcnt.B[EBX]
	DECL	dcb_tcpsndavl[EDI]
	DECL	dcb_tcpsndaloc[EDI]
	RET

;Here if error

4$:	POPL	EDX			;Fix up the stack
	RET
.PAGE
	.SBTTL	xostcpPutBlk - Subroutine to store output data into a TCP packet

;Subroutine to store output data into a TCP packet - must be called in
;  extended fork context - data will be split between packets if necessary
;	c{ES:EBX} = Address of buffer containing data
;	c{ECX}    = Amount to output
;	c{EDI}    = Offset of DCB
;	c{ESI}    = Offset of SDB
;	CALL	xostcpPutBlk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM ts_buffer, 8
FRM ts_count , 4
ts_SIZE=!$$$

xostcpPutBlk::
	ENTER	ts_SIZE, 0
	MOVL	ts_buffer+0.B[EBP], EBX	;Store buffer address
	MOVL	ts_buffer+4.B[EBP], ES
	MOVL	ts_count.B[EBP], ECX	;Store amount to store
2$:	CALL	tcpchkspace		;Check for available space
	JC	10$.S			;If error
	MOVL	ECX, ts_count.B[EBP]
	CMPL	ECX, dcb_tcpsndavl[EDI]	;Is there enough space available here?
	JBE	4$.S			;Yes
	MOVL	ECX, dcb_tcpsndavl[EDI]	;No - just store what we can here
4$:	SUBL	ts_count.B[EBP], ECX
	SUBL	dcb_tcpsndavl[EDI], ECX
	SUBL	dcb_tcpsndaloc[EDI], ECX
	MOVL	EBX, dcb_tcpsndpktb[EDI]
	ADDL	npb_count.B[EBX], ECX
	ADDL	npb_apcnt.B[EBX], ECX
	PUSHL	EDI
	PUSHL	ESI
	LFSL	ESI, ts_buffer.B[EBP]
	ADDL	ts_buffer.B[EBP], ECX
	MOVL	EAX, dcb_tcpsndpktp[EDI]
	ADDL	dcb_tcpsndpktp[EDI], ECX
	MOVL	EDI, EAX
	PUSHL	DS
	POPL	ES
	CLD
	CMPL	ECX, #8.B		;More than 8 bytes to store?
	JBE	6$.S			;No
	MOVL	EAX, ECX		;Yes - get destination to a long
	MOVL	ECX, EDI		;  boundry
	NEGL	ECX
	ANDL	ECX, #03h.B
	SUBL	EAX, ECX
	RMOVSB	[EDI], FS:[ESI]
	MOVL	ECX, EAX
	SHRL	ECX, #2t		;Change to number of longs (round down)
	RMOVSL	[EDI], FS:[ESI]		;Copy most of it
	MOVL	ECX, EAX		;Copy any bytes left over
	ANDL	ECX, #3.B
6$:	RMOVSB	[EDI], FS:[ESI]
	POPL	ESI
	POPL	EDI
	CMPL	ts_count.B[EBP], #0.B	;Are we finished?
	JNE	2$.S			;No - continue
10$:	LEAVE				;Yes
ret030:	RET
.PAGE
;Subroutine to ensure have buffer space to store at least one byte
;	c{ECX} = Total amount needed
;	CALL	tcpchkspace
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tcpchkspace:
	CMPL	dcb_tcpsndavl[EDI], #0.B ;Will anything fit in the current
					 ;  chunk?
	JNE	ret030.S		;Yes - nothing needed here
	CMPL	dcb_tcpsndaloc[EDI], #0.B ;No - will anything fit in the
					  ;  current packet?
	JNE	4$.S			;Yes
	CMPL	ECX, dcb_tcpsndneed[EDI] ;No
	JAE	2$.S
	MOVL	ECX, dcb_tcpsndneed[EDI]
2$:	JMP	xostcpAlloc		;Allocate a new packet (this will push
					;  the current packet first)

;Here with some space available

4$:	CMPL	ECX, dcb_tcpsndneed[EDI] ;Need more than he's asking for?
	JAE	6$.S			;No
	MOVL	ECX, dcb_tcpsndneed[EDI] ;Yes
tcpchkspace2:
6$:	CMPL	ECX, dcb_tcpsndaloc[EDI] ;Want more than will fit in the packet?
	JBE	8$.S			;No
	MOVL	ECX, dcb_tcpsndaloc[EDI] ;Yes - just get as much as we can
8$:	ADDL	ECX, #npc_mSIZE.B
	ADDL	ECX, #npc_mSIZE.B
	MOVL	EDX, dcb_tcpsndpktc[EDI]
	CALL	xosnetExtendBufr##	;Allocate another buffer chunk
	JC	curperr.S		;If error
	MOVL	dcb_tcpsndpktc[EDI], EDX ;OK
	MOVL	dcb_tcpsndpktp[EDI], EDX
	MOVZBL	EDX, npc_sizex.B[EDX]	;Get size of this chunk
	MOVL	EDX, knlXmbSize##[EDX*4]
	SUBL	EDX, #npc_mSIZE.B
	SUBL	dcb_tcpsndneed[EDI], EDX ;Reduce amount needed
	JNS	10$.S
	MOVL	dcb_tcpsndneed[EDI], #0
10$:	CMPL	EDX, dcb_tcpsndaloc[EDI] ;Bigger than what is left in packet?
	JBE	12$.S			;No
	MOVL	EDX, dcb_tcpsndaloc[EDI] ;Yes - use what is left
12$:	MOVL	dcb_tcpsndavl[EDI], EDX
	CLC
	RET

;Here with error allocating another chunk - discard the current packet and
;  return the error

curperr:PUSHL	EAX			;Save error code
	MOVL	EBX, dcb_tcpsndpktb[EDI] ;Give up the packet
	CALL	xosnetGiveBufr##
	CLRL	EAX
	MOVL	dcb_tcpsndpktb[EDI], EAX ;Clear pointers to the packet and
	MOVL	dcb_tcpsndpktp[EDI], EAX ;  the associated counts
	MOVL	dcb_tcpsndpktc[EDI], EAX
	MOVL	dcb_tcpsndavl[EDI], EAX
	MOVL	dcb_tcpsndaloc[EDI], EAX
	POPL	EAX			;Restore error code
	STC				;Indicate error
	RET
.PAGE
	.SBTTL	xostcpPush - Subroutine to push current buffered TCP output packet

;Subroutine to push current TCP output packet - this routine implements the
;  Nagel xosorithm under the control of the NMTCP$CONP network mode bit
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpPush
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Number of TCP data bytes output

xostcpPush:
	CLRL	ECX			;Clear C in cause we don't output it now
	MOVL	EBX, dcb_tcpsndpktb[EDI]
	TESTL	EBX, EBX
	JE	2$.S			;If no packet
	ORB	npb_sts.B[EBX], #NPS$PUSHED ;Indicate packet is pushed
	MOVZBL	EAX, npb_tpofs.B[EBX]
	ORB	tcp_code.B[EBX+EAX], #TCPC$PSH
	BTL	dcb_netmode.B[EDI], #NMTCP%CONP ;Should the push be conditional?
	JNC	4$.S			;No
	CMPL	dcb_tcpsndhead[EDI], #0.B ;Yes - have any unacked packets?
	JE	4$.S			;No - push it now
	MOVL	EAX, npb_apcnt.B[EBX]	;Yes - is the packet more than half the
	ADDL	EAX, EAX		;  window or the maximum size?
	CMPL	EAX, dcb_tcpsndwinm[EDI]
	JAE	4$.S			;Yes
	MOVL	EDX, dcb_netidb.B[EDI]	;Maybe
	CMPL	idb_hwpktsz.B[EDX], EAX
	JL	4$.S			;Yes - output it now
2$:	RET				;No - don't push it yet

;Subroutine to push current TCP output packet unconditionally
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	tcppushu
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Number of TCP data bytes output

tcppushu::
	CLRL	ECX
	MOVL	EBX, dcb_tcpsndpktb[EDI] ;Get packet buffer to output
	TESTL	EBX, EBX		;Do we have one?
	JE	2$.S			;No
	ORB	npb_sts.B[EBX], #NPS$PUSHED ;Yes - indicate packet is pushed
	MOVZBL	EAX, npb_tpofs.B[EBX]
	ORB	tcp_code.B[EBX+EAX], #TCPC$PSH
4$:	MOVL	dcb_tcpsndpktb[EDI], ECX ;Clear pointers to the packet and the
	MOVL	dcb_tcpsndpktp[EDI], ECX ;  associated counts
	MOVL	dcb_tcpsndpktc[EDI], ECX
	MOVL	dcb_tcpsndavl[EDI], ECX
	MOVL	dcb_tcpsndaloc[EDI], ECX
	PUSHL	npb_apcnt.B[EBX]	;Save size of the packet
	CALL	tcpsendpkt		;Send the packet
	POPL	ECX			;Restore size
	RET				;Return
.PAGE
;Subroutine to send current buffered TCP packet - may be called in extended
;  fork context or from device fork level.  The packet is always placed on
;  the send list.  If the send list was empty, the retransmit/probe timer is
;  started.  If the packet fits entirely in the available send window, it is
;  output.  If it does not fit entirely in the window, it is simply left on
;  the list.  It will eventually be output, either by the code in procpkt
;  which opens the window or by the retransmit code (in which case it is used
;  either to fill out the window or as a window probe)
;	c{EBX} = Offset of packet buffer
;	CALL	tcpsendpkt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tcpsendpkt::

;First, store the sequence number in the packet (we also store it in the packet
;  header in internal byte order so we can use it easily later)

	MOVL	EAX, dcb_tcpsndsnext[EDI] ;Get next send sequence number to use
	MOVL	npb_seqnum.B[EBX], EAX	;Store it in the header in our normal
	XCHGB	AL, AH			;  byte order
	RORL	EAX, #16t		;Reverse the byte order
	XCHGB	AL, AH			;Store it in the packet in newwork byte
	MOVZBL	ECX, npb_tpofs.B[EBX]	;  order
	MOVL	tcp_seqnum.B[EBX+ECX], EAX
	MOVL	EAX, npb_apcnt.B[EBX]
	BTL	tcp_code.B[EBX+ECX], #TCPC%FIN
	ADCL	EAX, #0.B
	ADDL	dcb_tcpsndsnext[EDI], EAX ;Bump our next send sequence number

;Link the packet to the tail of the send list

	MOVL	EAX, dcb_tcpsndtail[EDI] ;Get current last packet
	MOVL	dcb_tcpsndtail[EDI], EBX ;Make this the new last packet
	TESTL	EAX, EAX		;Was the list empty?
	JNE	4$.S			;No
	MOVL	dcb_tcpsndhead[EDI], EBX ;Yes - update head pointer
	PUSHL	EBX
	CALL	tcprexmitreq		;Start the retransmit/probe timer
	POPL	EBX
	CMPL	dcb_tcprxmtbgn[EDI], #0.B ;Are we timing a transmission now?
	JNE	6$.S			;Yes
	MOVL	EAX, knlTickTtl##	 ;No - store current time for
	MOVL	dcb_tcprxmtbgn[EDI], EAX ;  retransmission timing
	JMP	6$.S

4$:	MOVL	npb_next.B[EAX], EBX
6$:	CLRL	EAX
	MOVL	npb_next.B[EBX], EAX

;Now see if we can really output the packet now

	CMPL	dcb_tcpsndover[EDI], #0.B ;Already have some overcommitted
					  ;  packets?
	JG	12$			;Yes
	MOVL	EAX, npb_apcnt.B[EBX]	 ;No - will the entire packet fit in the
	CMPL	EAX, dcb_tcpsndwina[EDI] ;  window?
	JG	12$.S			;No
	TESTB	npb_sts.B[EBX], #NPS$OVRCMTD ;Yes - was packet overcommitted?
	JE	8$.S			;No
	ANDB	npb_sts.B[EBX], #~NPS$OVRCMTD ;Yes - but not any more
	DECL	dcb_tcpsndover[EBX]
8$:	MOVZBL	ECX, npb_tpofs.B[EBX]
	BTL	tcp_code.B[EBX+ECX], #TCPC%FIN
	ADCL	EAX, #0.B
	ADDL	dcb_tcpsndsnum[EDI], EAX ;Bump actual send sequence number
	SUBL	dcb_tcpsndwina[EDI], EAX ;Reduce the available window
	MOVL	EAX, dcb_tcpsndsnum[EDI]
	CMPL	EAX, dcb_tcpsndsnext[EDI]
	JNE	20$.S
	MOVZBL	EAX, npb_apofs.B[EBX]	;Calculate output count
	ADDL	EAX, npb_apcnt.B[EBX]
	MOVL	npb_count.B[EBX], EAX	;Store output count for packet
	TESTB	dcb_tcpsts1.B[EDI], #TCPS1$REXMIT ;Are we retransmitting now?
	JNE	ret034.S		;Yes - can't send it now
tcpsendpk2:				;Store ACK number and calculate TCP
	BTSL	npb_sts.B[EBX], #NPS%XMITD ;Have we transmitted this one yet?
	JNC	tcpsendpk4.S		;No
	ORB	npb_sts.B[EBX], #NPS$REXMITD ;Yes - indicate retransmitted
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the retransmission
	INCL	tpdb_tcpcntrexmit[EAX]
tcpsendpk4:
	CALL	tcpsetack		;  checksum
	CALL	xosipsSendSetup##	;Set up IP part of packet header
	MOVL	ESI, dcb_netsdb.B[EDI]	;Make sure have SDB offset
	MOVL	EAX, #ret034
	CALL	xossnpSendPkt##		;Output the packet and return
	RET

;Here if entire packet will not fit in the available output window

12$:	TESTB	npb_sts.B[EBX], #NPS$OVRCMTD ;Was the packet overcommitted?
	JNE	14$.S			;Yes
	ORB	npb_sts.B[EBX], #NPS$OVRCMTD ;No - but it is now
	INCL	dcb_tcpsndover[EDI]	;Count the overcommitted packet
14$:	CLRL	EAX			;Clear the output count
	MOVL	npb_count.B[EBX], EAX
ret034:	RET

20$:	CRASH	SEQ8
.PAGE
;Here if have timeout before receiving ACK for a packet we have sent

tcprexmit:
	MOVL	dcb_tcprxmtwake[EDI], #0
	MOVL	ESI, dcb_netsdb.B[EDI]	;Get offset of the SDB
	MOVL	EBX, dcb_tcpsndhead[EDI] ;Get first packet on the send list
	CMPL	npb_count.B[EBX], #0.B	;Have we output this packet yet?
	JNE	14$			;Yes

;Here with a packet which has never been output - this happens when we put a
;  packet on the send list which does not fit completely in the available
;  output window and the timer goes off before the window opens enough to
;  send the entire packet.  If we are in "normal" TCP mode we do the following:
;	If the window is completely closed we make this a one byte window probe
;	and send it.  If the window is not completely closed we send as much of
;	this packet as will fit in the window.  (It should never all fit,
;	since if this were the case, we would have sent it when the window
;	opened.)  In either case, the packet remains overcommitted.
;  If we are in "funny" TCP mode we do the following:
;	We send the entire packet as a window probe.  The packet remains
;	overcommitted.

	TESTB	dcb_ipssts1.B[EDI], #IPSS1$NOMERGE ;In "funny" mode?
	JNE	8$.S			;Yes
	CMPL	dcb_tcpsndwina[EDI], #0.B ;No - is the window closed now?
	JG	10$.S			;No
	PUSHL	EBX			;Yes
	MOVL	ECX, #60t		;Send a 1-byte window probe (we have
	CALL	xosnetGetBufr##		;  to allocate a new buffer for this
	JC	6$.S			;  packet since the driver output
	CALL	tcpsetpkt		;  routine may zero data to 0-pad short
	JC	4$.S			;  Ethernet packets!)
	MOVZBL	ECX, npb_tpofs.B[EBX]
	MOVL	EAX, dcb_tcpsndsnum[EDI]
	MOVL	npb_seqnum.B[EBX], EAX
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_seqnum.B[EBX+ECX], EAX
	POPL	ECX
	MOVZBL	EAX, npb_apofs.B[ECX]
	MOVB	AL, [ECX+EAX]		;Get first data byte
	MOVZBL	ECX, npb_apofs.B[EBX]
	MOVB	[EBX+ECX], AL		;Store in the probe packet
	INCL	npb_count.B[EBX]
	INCL	npb_apcnt.B[EBX]
	CALL	tcpsetack
	CALL	xosipsSendSetup##	;Set up IP part of packet header
	MOVL	ESI, dcb_netsdb.B[EDI]	;Make sure have SDB offset
	MOVL	EAX, #xosnetGiveBufr##
	CALL	xossnpSendPkt##		;Output the packet and return
2$:	JMP	26$

4$:	CALL	xosnetGiveBufr##
6$:	POPL	ECX
	JMP	2$.S

;Here if in "funny" TCP mode.  In this mode we never split packets for
;  compatibility with the old VAX TAMserver code.

8$:	MOVL	EAX, npb_apcnt.B[EBX]	;Output the entire packet
	JMP	12$.S

;Here if window is open some amount - we send as much of the first packet as
;  will fit in the window to attempt to close it

10$:	MOVL	EAX, dcb_tcpsndwina[EDI] ;Get window size
	SUBL	dcb_tcpsndwina[EDI], EAX ;Update window amount
	ADDL	dcb_tcpsndsnum[EDI], EAX ;Update sequence number sent
12$:	MOVZBL	EDX, npb_apofs.B[EBX]
	ADDL	EAX, EDX
	MOVL	npb_count.B[EBX], EAX	;Store amount to output
	JMP	24$

;Here with packet which we have already output

14$:	CMPL	dcb_tcpsndwina[EDI], #0.B ;Are we probing the window?
	JG	16$.S			;No
	MOVL	EAX, dcb_tcprcvanum.B[EDI] ;Maybe
	CMPL	EAX, dcb_tcpsndsnum[EDI]
	JE	24$.S			;Yes - don't change the retransmit
					;  interval
16$:	MOVL	EAX, dcb_tcprxmtave[EDI] ;No - double the retransmit interval
	MOVL	dcb_tcprxmtvar[EDI], EAX
	SHLL	dcb_tcprxmtint[EDI], #1
	SHLL	dcb_tcprxmtave[EDI], #1
	MOVL	dcb_tcprxmtvar[EDI], #0
	CMPL	dcb_tcprxmtint[EDI], #TIMEOUT_TRNMAX/FDPERTICK ;Too big?
	JB	18$.S			;No
	MOVL	dcb_tcprxmtint[EDI], #TIMEOUT_TRNMAX/FDPERTICK     ;Yes - set it
	MOVL	dcb_tcprxmtave[EDI], #{TIMEOUT_TRNMAX/FDPERTICK}*2 ;  to the max
18$:
.IF NE $$TCPTIME
	MOVL	EDX, tcptimepnt
	MOVW	[EDX], #-1
	MOVL	EAX, npb_count.B[EBX]
	MOVW	2.B[EDX], AX
	MOVL	EAX, dcb_tcprxmtint[EDI]
	MOVL	4.B[EDX], EAX
	MOVL	EAX, dcb_tcprxmtave[EDI]
	ADDL	EAX, EAX
	MOVL	8t.B[EDX], EAX
	MOVL	EAX, dcb_tcprxmtvar[EDI]
	SHLL	EAX, #2t
	MOVL	12t.B[EDX], EAX
	ADDL	EDX, #16t.B
	CMPL	EDX, #tcptimeend
	JB	20$.S
	MOVL	EDX, #tcptimering
20$:	MOVL	tcptimepnt, EDX
.ENDC
	CMPL	npb_nextsnd.B[EBX], #-1.B ;Still outputting this packet?
	JNE	tcprexmitreq.S		;Yes - just restart the timer
	ORB	dcb_tcpsts1.B[EDI], #TCPS1$REXMIT ;No - indicate retransmitting
	INCB	dcb_tcpretrycnt.B[EDI]	;Increment the retry count
	MOVB	AL, dcb_tcpretrycnt.B[EDI] ;Get retry number
	CMPB	AL, dcb_tcpretry1.B[EDI];At first threshold?
	JNE	22$.S			;No - go on
	MOVL	EAX, dcb_ipsrmtaddr.B[EDI] ;Yes - remove entry from the routing
	PUSHL	EDI			  ;  table to force us to re-do whatever
	MOVL	EDI, dcb_netpdb.B[EDI]	  ;  we do to get the hardware address
	PUSHL	EBX
	CALL	xosipsRtRmvOne##
	POPL	EBX
	POPL	EDI
	JMP	24$.S

;Here if not exactly at first threshold

22$:	CMPB	dcb_tcpretry2.B[EDI], #0 ;Want infinite retry?
	JE	28$.S			;Yes
	CMPB	AL, dcb_tcpretry2.B[EDI] ;No - at second threshold?
	JAE	30$.S			;Yes - its time to fail!
24$:	CALL	tcpsendpk2
26$:	CALL	tcprexmitreq		;Restart the timer (SHOULD CHANGE THIS
	CLC				;  TO REUSE THE SAME WAKE BLOCK!!!)
	RET

;Here if want infinite retry

28$:	CMPB	AL, #255t		;At maximum value?
	JB	24$.S			;No
	DECB	dcb_tcpretrycnt.B[EDI]	;Yes - keep it there
	JMP	24$.S

;Here if have retransmitted a packet too many times

30$:	MOVL	EAX, #ER_NCLST		;Get error code
	CALL	xostcpGiveAll		;Give up all buffers
	CALL	tcplost#		;Indicate connection lost
	CLC
	RET
.PAGE
	.SBTTL	tcprexmitreq - Subroutine to enter retransmit wake request for TCP

;Subroutine to enter retransmit wake request for TCP
;	CALL	tcprexmitreq
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tcprexmitreq:
	MOVL	EAX, dcb_tcprxmtint[EDI] ;Get the retransmit interval
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;In established state?
	JNE	2$.S			;No - can't be a pure window probe
	CMPL	dcb_tcpsndwina[EDI], #0.B ;Yes - is the window closed now?
	JNE	2$.S			;No - can't be a pure window probe
	MOVL	EBX, dcb_tcprcvanum.B[EDI] ;Yes - is this a pure window probe?
	CMPL	EBX, dcb_tcpsndsnum[EDI]
	JNE	2$.S			;No
	CMPL	EAX, #TIMEOUT_PROBE/FDPERTICK ;Yes - is it too small?
	JA	2$.S			;No
	MOVL	EAX, #TIMEOUT_PROBE/FDPERTICK ;Yes - use the miminum value
2$:	MOVL	EBX, #tcprexmit
xostcpTimerReq:
	PUSHL	ESI
	CMPL	dcb_tcprxmtwake[EDI], #0.B ;Have a timer going now?
	JE	4$.S			;No
	MOVL	ESI, dcb_tcprxmtwake[EDI] ;Yes - clear it first
	CALL	knlWakeRemove##
4$:	CALL	knlWakeRequest##	;Enter the wake request
	MOVL	dcb_tcprxmtwake[EDI], ESI ;Store offset of the timer block (this
	POPL	ESI			  ;  will be 0 if an error occured)
	RET				;Finished

	.SBTTL	xostcpTimerRmv - Subroutine to remove retransmit wake request for TCP

;Subroutine to remove retransmit wake request for TCP
;	CALL	xostcpTimerRmv

xostcpTimerRmv::
	CMPL	dcb_tcprxmtwake[EDI], #0.B ;Have a timer going now?
	JE	ret040.S		;No
	PUSHL	ESI			;Yes - kill it
	MOVL	ESI, dcb_tcprxmtwake[EDI]
	CALL	knlWakeRemove##
	CLRL	ESI
	MOVL	dcb_tcprxmtwake[EDI], ESI
	POPL	ESI
ret040:	RET
.PAGE
	.SBTTL	xostcpFatal - Subroutine to indicate have had fatal application error

;Subroutine to indicate have had fatal application level protocol error
;	CALL	xostcpFatal
;	C:set always
;  EAX is preserved

xostcpFatal:
	PUSHL	EAX
	ORB	dcb_tcpsts1.B[EDI], #TCPS1$FATAL ;Indicate fatal error
	CALL	xostcpGiveAll		;Give up all buffers we have
	MOVL	ECX, #60t
	CALL	xosnetGetBufr##		;Get a network buffer
	JC	2$.S			;Forget it if can't get one
	CALL	tcpsetpkt		;Set up the packet header
	JC	6$.S
	MOVZBL	ECX, npb_tpofs.B[EBX]
	MOVL	EAX, dcb_tcpsndsnum[EDI]
	MOVL	npb_seqnum.B[EBX], EAX
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_seqnum.B[EBX+ECX], EAX
	CLRL	EAX
	MOVL	tcp_acknum.B[EBX+ECX], EAX
	MOVW	tcp_window.B[EBX+ECX], AX
	ORB	tcp_code.B[EBX+ECX], #TCPC$RST ;Make this a reset packet
	CALL	tcpchksum		;Calculate the checksum
	CALL	xosipsSendSetup##
	MOVL	ESI, dcb_netsdb.B[EDI]
	MOVL	EAX, #xosnetGiveBufr##
	CALL	xossnpSendPkt##		;Send the packet and then give it up
	MOVL	EAX, dcb_ipstpdb.B[EDI]	;Count the reset
	INCL	tpdb_tcpcntrstsent[EAX]
2$:	CALL	xostcpHashClr		;Remove for the input hash list
	MOVB	dcb_tcpstate.B[EDI], #TCPS_CLOSED ;Indicate idle
4$:	POPL	EAX
	STC
	RET

6$:	CALL	xosnetGiveBufr##
	JMP	4$.S
.PAGE
	.SBTTL	xostcpGiveAll - Subroutine to give up all packet buffers

;Subroutine to give up all packet buffers
;	c{EDI} = Offset of DCB
;	CALL	xostcpGiveAll
;  c{EAX} is respected

xostcpGiveAll::
	PUSHL	EAX
	CALL	xostcpTimerRmv		;Stop retransmit timer if its running
	CMPL	dcb_tcpackwake[EDI], #0.B ;Is the ACK timer running?
	JE	2$.S			;No
	PUSHL	ESI			;Yes - stop it
	MOVL	ESI, dcb_tcpackwake[EDI]
	CLRL	EAX
	MOVL	dcb_tcpackwake[EDI], EAX
	CALL	knlWakeRemove##
	POPL	ESI
2$:	POPL	EAX
giveal2:MOVL	EBX, dcb_tcpsndhead[EDI] ;Give up all held packets
	TESTL	EBX, EBX
	JE	4$.S
	CLRL	ECX
	MOVL	dcb_tcpsndhead[EDI], ECX
	MOVL	dcb_tcpsndtail[EDI], ECX
	CALL	xosnetGiveList##
4$:	MOVL	EBX, dcb_tcprcvoosl[EDI] ;Do we have any out-of-sequence
	TESTL	EBX, EBX		 ;  packets?
	JE	6$.S			;No
	CLRL	ECX			;Yes
	MOVL	dcb_tcprcvoosl[EDI], ECX
	CALL	xosnetGiveList##
6$:	MOVL	EBX, dcb_tcprcvtakb.B[EDI] ;Do we have any receive packets?
	TESTL	EBX, EBX
	JE	xostcpGiveSnd.S		;No
	CLRL	ECX			;Yes
	MOVL	dcb_tcprcvtakb.B[EDI], ECX
	MOVL	dcb_tcprcvtakp.B[EDI], ECX
	MOVL	dcb_tcprcvtakc.B[EDI], ECX
	MOVL	dcb_tcprcvavl[EDI], ECX
	MOVL	dcb_tcprcvputb.B[EDI], ECX
	MOVL	dcb_tcprcvputp.B[EDI], ECX
	MOVL	dcb_tcprcvcnt.B[EDI], ECX
	CALL	xosnetGiveList##
xostcpGiveSnd:
	MOVL	EBX, dcb_tcpsndpktb[EDI] ;Do we have an output packet buffered?
	TESTL	EBX, EBX
	JE	ret050.S		;No
	CLRL	ECX			;Yes
	MOVL	dcb_tcpsndpktb[EDI], ECX
	MOVL	dcb_tcpsndpktp[EDI], ECX
	MOVL	dcb_tcpsndavl[EDI], ECX
	CALL	xosnetGiveBufr##	;Give it up
	RET
.PAGE
	.SBTTL	xostcpOpenWindow - Subroutine to open the receive window

;Subroutine to open the receive window
;	CALL	xostcpOpenWindow
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  EAX and ECX are preserved

xostcpOpenWindow:
	PUSHL	EAX
	MOVL	EAX, dcb_tcprcvwinb.B[EDI] ;Get amount window has changed since
	SUBL	EAX, dcb_tcprcvwina.B[EDI] ;  we last announced it
	ADDL	EAX, dcb_tcprcvsnum.B[EDI] ;Allow for pending but unsent ACKS
	SUBL	EAX, dcb_tcprcvtnum.B[EDI]
	JL	2$.S			;Always update if smaller (this should
					;  normally not be the case!)
	SHLL	EAX, #2			;Changed by more than 1/4?
	CMPL	EAX, dcb_tcprcvwinm.B[EDI]
	JB	8$.S			;No - don't do it yet!
2$:	PUSHL	ECX			;Yes
	MOVL	ECX, dcb_tcprcvoosl[EDI] ;Do we have any out-of-sequence
	TESTL	ECX, ECX		 ;  packets?
	JE	4$.S			;No
	MOVL	EAX, npb_seqnum.B[ECX]	   ;Yes - is the first one the next one
	CMPL	EAX, dcb_tcprcvsnum.B[EDI] ;  we want?
	JE	6$.S			;Yes - don't send window update now
4$:	CALL	tcpsendacknow		;No - send window update
6$:	POPL	ECX
8$:	POPL	EAX
	CLC				;Always return with C clear
ret050:	RET
.PAGE
	.SBTTL	tcpsetack - Subroutine to set up ACK number and window value

;Subroutine to set up ACK number and window value in TCP header and to
;  calculate and store the checksum for the TCP packet
;	c{EBX} = Offset of packet
;	c{EDI} = Offset of DCB
;	CALL	tcpsetack

tcpsetack::
	CMPL	dcb_tcpackwake[EDI], #0.B ;Is the ACK timer running now?
	JE	2$.S			;No
	PUSHL	ESI			;Yes - stop it
	MOVL	ESI, dcb_tcpackwake[EDI]
	CLRL	EAX
	MOVL	dcb_tcpackwake[EDI], EAX
	CALL	knlWakeRemove##
	POPL	ESI
2$:	MOVZBL	ECX, npb_tpofs.B[EBX]
	MOVL	EAX, dcb_tcprcvsnum.B[EDI] ;Get receive sequence number
	MOVL	dcb_tcprcvtnum.B[EDI], EAX ;Remember we have sent an ACK for it
	XCHGB	AL, AH			;Change to network byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	tcp_acknum.B[EBX+ECX], EAX ;Store in the packet
	MOVL	EAX, dcb_tcprcvwinb.B[EDI] ;Get window size
	MOVL	dcb_tcprcvwina.B[EDI], EAX ;Remember we have sent this value
	XCHGB	AL, AH			;Change to network byte order
	MOVW	tcp_window.B[EBX+ECX], AX ;Store in the packet
	ORB	tcp_code.B[EBX+ECX], #TCPC$ACK
tcpchksum::
	MOVL	EDX, dcb_ipstpdb.B[EDI]	;Get offset of the TPDB
	INCL	tpdb_tcpcntpktout.B[EDX] ;Bump output counts
	MOVL	ECX, npb_count.B[EBX]	;Get total length of packet
	ADDL	tpdb_tcpseqnumber.B[EDX], ECX ;Bump initial TCP sequence number
	MOVZBL	EAX, npb_tpofs.B[EBX]	;Get offset of start of TCP part
	SUBL	ECX, EAX		;Calculate length of TCP part
	ADDL	tpdb_tcpcntbyteout.B[EDX], ECX
	MOVL	EAX, dcb_netpdb.B[EDI]	;Need to calculate checksum value?
tcpchksum2:
	TESTB	pdb_ipchksumh[EAX], #PCSH$GEN
	JE	ret050.S		;No - nothing more needed here
	PUSHL	ESI			;The first 2 longs for the pseudo-header
					;  are found in the IP header
	MOVZBL	ESI, npb_npofs.B[EBX]	     ;Get offset of the IP header source
	LEAL	ESI, ip_srcipaddr.B[ESI+EBX] ;  IP address field
	CLD
	LODSL	[ESI]			;Get first 32 bits
	ADDL	EAX, [ESI]		;Add in next 32 bits (destination IP
	ADCL	EAX, #0.B		;  address)
	MOVZBL	ESI, npb_tpofs.B[EBX]	;Point to the TCP header
	ADDL	ESI, EBX
	MOVW	tcp_checksum.B[ESI], #0	;Make sure checksum field is 0
	MOVL	EDX, npb_count.B[EBX]	;Get total length of TCP part (including
	MOVZBL	ECX, npb_tpofs.B[EBX]	;  the TCP header)
	SUBL	EDX, ECX
	MOVL	ECX, EDX		;Copy it for use below as a count
	XCHGB	DL, DH
	SHLL	EDX, #16t		;Position it for the checksum
	MOVB	DH, #IPP_TCP		;Include the protocol value
	ADDL	EAX, EDX		;Add into checksum value
	ADCL	EAX, #0.B
	PUSHL	EBX			;No
	MOVZBL	EDX, npb_sizex.B[EBX]	 ;Yes - get amount remaining in this
	MOVL	EDX, knlXmbSize##[EDX*4] ;  chunk
	LEAL	EDX, -npb_mSIZE.B[EBX+EDX]
	SUBL	EDX, ESI
4$:	CMPL	ECX, EDX		;Using data beyond this chunk?
	JBE	14$.S			;No - its the last one
	SUBL	ECX, EDX		;Yes - calculate and save amount beyond
	PUSHL	ECX			;  this chunk
	MOVL	ECX, EDX		;Get count for this chunk in right place
	SHRL	ECX, #2			;Change to number of longs (round down)
	JE	8$.S			;If no whole longs
6$:	ADDL	EAX, [ESI]		;Add in next 4 bytes
	ADCL	EAX, #0.B		;Make it a 1's complement add
	ADDL	ESI, #4.B		;Bump pointer
	LOOP	ECX, 6$			;Continue if more
8$:	ANDL	EDX, #03.B		;Get number of bytes left over
	JMPIL	CS:csdsp1[EDX*4]	;Dispatch on it (Must do it this way to
					;  be sure we don't access memory past
					;  the end of the data, since the next
					;  byte may not be allocated!)

	.MOD	4
csdsp1:	.LONG	csseg0		;0 bytes left over
	.LONG	csseg1		;1 byte left over
	.LONG	csseg2		;2 bytes left over
	.LONG	csseg3		;3 bytes left over

;Here if have 1 byte left over in chunk

csseg1:	MOVZBL	ECX, [ESI]		;Get 1 byte
	JMP	10$.S

;Here if have 2 bytes left over in chunk

csseg2:	MOVZWL	ECX, [ESI]		;Get 2 bytes
	JMP	10$.S

;Here if have 3 bytes left over in chunk

csseg3:	MOVZWL	ECX, 1.B[ESI]		;Get 3 bytes
	SHLL	ECX, #8
	MOVB	CL, [ESI]
10$:	ADDL	EAX, ECX		;Add in the final byte(s)
	ADCL	EAX, #0.B
csseg0:	POPL	ECX			;Restore amount remaining
	MOVL	EBX, npc_link.B[EBX]	;Advance to next chunk
	MOVL	ESI, EBX		;Were there an odd number of bytes in
	TESTB	DL, #1			;  the previous chunk? (This is possible
					;  if the hardware level header contains
					;  an odd number of bytes! We don't need
					;  to worry here about words being left
					;  over since its a 16 bit 1's
					;  complement checksum)
	JE	12$.S			;No - go on
	CLRL	EDX			;Yes - we must adjust for this
	MOVB	DH, [ESI]		;Get 1 byte
	INCL	ESI			;Adjust pointer
	DECL	ECX			;Adjust count
	ADDL	EAX, EDX		;Add into the checksum
	ADCL	EAX, #0.B
12$:	MOVZBL	EDX, npc_sizex.B[EBX]	;Get total size of this chunk
	MOVL	EDX, knlXmbSize##[EDX*4]
	SUBL	EDX, #npc_mSIZE.B
	JMP	4$.S			;Continue

;Here to add in last chunk to the checksum

14$:	POPL	EBX			;Restore offset of packet buffer
	CALL	xosipsChkSumFin##	;Calculate checksum for data part of
	NOTL	EAX			;  the packet
	MOVZBL	ECX, npb_tpofs.B[EBX]	;Store final checksum value
	MOVW	tcp_checksum.B[EBX+ECX], AX
	POPL	ESI
	RET
.PAGE
	.SBTTL	xostcpGetLong - Subroutine to get received data long

;Subroutine to get received data long - must be called in extended fork
;  context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpGetLong
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

xostcpGetLong::
	PUSHL	#0.B			;Clear value
	CALL	xostcpGetByte		;Get high order byte
	JC	2$.S
	MOVB	3.B[ESP], AL		;Store it
	CALL	xostcpGetByte		;Get next byte
	MOVB	2.B[ESP], AL		;Store it
	JNC	4$.S			;Continue if OK
2$:	POPL	ECX			;If error
	RET

	.SBTTL	xostcpGetWord - Subroutine to get received data word

;Subroutine to get received data word - must be called in extended fork
;  context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpGetWord
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

xostcpGetWord::
	PUSHL	#0.B			;Clear value
4$:	CALL	xostcpGetByte		;Get high order byte
	JC	2$.S
	MOVB	1.B[ESP], AL		;Store it
	CALL	xostcpGetByte		;Get low order byte
	JC	2$.S
	MOVB	[ESP], AL		;Store it
	POPL	EAX			;Get value
	RET				;Finished
.PAGE
	.SBTTL	xostcpGetByte - Subroutine to get received data byte

;Subroutine to get received data byte - must be called in extended fork
;  context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of SDB
;	CALL	xostcpGetByte
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c(AL) = Data byte

xostcpGetByte::
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any data available now?
	JNE	4$.S			;Yes
2$:	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;No - still have a connection?
	JNE	14$.S			;No
3$:	CALL	tcprspwait		;Yes - wait until have some data
	JC	xostcpFatal		;If error
4$:	MOVL	EBX, dcb_tcprcvtakb.B[EDI] ;Point to receive buffer
	TESTL	EBX, EBX		;Really have a buffer?
	JE	12$.S			;No
	MOVL	EDX, dcb_tcprcvtakp.B[EDI] ;Yes - point to receive data
	MOVZBL	EAX, [EDX]		;Get a data byte
	INCL	dcb_tcprcvtakp.B[EDI]	;Bump pointer
	DECL	dcb_tcprcvtakc.B[EBX]	;Reduce count for this packet
	DECL	dcb_tcprcvcnt.B[EDI]	;Reduce total amount available
	INCL	dcb_tcprcvwinb.B[EDI]	;Open receive window
	JNE	6$.S			;If still something in this buffer

;Here if current buffer is now empty

tcpget2:PUSHL	npb_next.B[EBX]		;Give up this buffer
	CALL	xosnetGiveBufr##
	POPL	EBX
	MOVL	dcb_tcprcvtakb.B[EDI], EBX ;Update our pointer
	TESTL	EBX, EBX		;Have another buffer?
	JNE	10$.S			;Yes
	MOVL	dcb_tcprcvtakp.B[EDI], EBX ;No - clear pointers
	MOVL	dcb_tcprcvputb.B[EDI], EBX
	MOVL	dcb_tcprcvputp.B[EDI], EBX
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Make sure count is 0 (for debugging!)
	JNE	8$.S
6$:	RET

8$:	CRASH	BNRC			;[Bad Network Receive byte Count]

;Here if have another buffer

10$:	MOVZBL	EDX, npb_apofs.B[EBX]	;Get offset of start of data
	MOVL	ECX, npb_count.B[EBX]
	SUBL	ECX, EDX
	MOVL	dcb_tcprcvtakc.B[EDI], ECX
	ADDL	EDX, EBX
	MOVL	dcb_tcprcvtakp.B[EDI], EDX ;Update taker data pointer
	RET				;Finished

;Here if don't have a packet

12$:	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;Still have a connection?
	JE	2$.S			;Yes - continue trying
14$:	MOVL	EAX, #ER_NCLST		;No - report the lost connection
	CMPB	dcb_tcpstate.B[EDI], #TCPS_CLOSEWAIT
	JNE	16$.S
	MOVL	EAX, #ER_NCCLR
16$:	STC
	RET
.PAGE
	.SBTTL	xostcpGetBlk - Subroutine to get block of received data

;Subroutine to get block of received data - must be called in extended fork
;  context
;	c{EAX}    = Time-out amount
;	c{ES:EBX} = Address of buffer to receive data
;	c{ECX}    = Amount wanted
;	c{EDI}    = Offset of DCB
;	c{ESI}    = Offset of SDB
;	CALL	xostcpGetBlk
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Amount obtained
;	C:clr = Normal
;	  c{ECX} = Amount obtained

$$$=!0
FRM tgb_buffer , 8
FRM tgb_count  , 4
FRM tgb_amount , 4
FRM tgb_timeout, 4
tgb_SIZE=!$$$

xostcpGetBlk::
	ENTER	tgb_SIZE, 0
	MOVL	tgb_timeout.B[EBP], EAX
	MOVL	tgb_buffer+0.B[EBP], EBX
	MOVL	tgb_buffer+4.B[EBP], ES
	MOVL	tgb_count.B[EBP], ECX
	CLRL	EAX			;Clear amount transfered
	MOVL	tgb_amount.B[EBP], EAX
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Have any data available now?
	JNE	4$.S			;Yes
2$:	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;No - still have a connection?
	JNE	6$.S			;No
	MOVL	EAX, tgb_timeout.B[EBP]	;Yes
	CALL	xosnetRspWait##		;Wait for data
	JC	8$.S
4$:	MOVL	EBX, dcb_tcprcvtakb.B[EDI] ;Point to receive buffer
	TESTL	EBX, EBX		;Do we really have one?
	JNE	10$.S			;Yes
	CMPB	dcb_tcpstate.B[EDI], #TCPS_ESTAB ;No - still have a connection?
	JE	2$.S			;Yes - continue trying
6$:	MOVL	EAX, #ER_NCLST		;No - report the lost connection
	CMPB	dcb_tcpstate.B[EDI], #TCPS_CLOSEWAIT
	JNE	8$.S
	MOVL	EAX, #ER_NCCLR
8$:	CLRL	ECX
	LEAVE
	STC
	RET

;Here with a packet

10$:	MOVL	ECX, tgb_count.B[EBP]	;Yes - get amount wanted
	CMPL	ECX, dcb_tcprcvtakc.B[EDI] ;Do we have this much in this buffer?
	JBE	12$.S			;Yes
	MOVL	ECX, dcb_tcprcvtakc.B[EDI] ;No - get amount we do have here
12$:	PUSHL	EDI			;Save registers we need here
	PUSHL	ESI
	PUSHL	ECX			;Save amount to transfer
	MOVL	ESI, dcb_tcprcvtakp.B[EDI] ;Point to data in our buffer
	LESL	EDI, tgb_buffer.B[EBP]	;Point to user's buffer
	CLD
14$:	TESTL	EDI, #03		;Need byte first?
	JE	16$.S			;No
	MOVSB	[EDI], [ESI]		;Yes
	DECL	ECX
	JNE	14$.S
	JMP	18$.S

16$:	MOVL	EAX, ECX		;Remember low order count bits
	SHRL	ECX, #2			;Change to number of longs
	RMOVSL	[EDI], [ESI]		;Transfer most of the block
	MOVL	ECX, EAX		;Transfer any bytes left over
	ANDL	ECX, #3.B
	RMOVSB	[EDI], [ESI]
18$:	POPL	ECX			;Restore registers
	POPL	ESI
	POPL	EDI
	ADDL	tgb_buffer+0.B[EBP], ECX ;Bump user buffer address
	SUBL	tgb_count.B[EBP], ECX	;Reduce amount wanted
	ADDL	tgb_amount.B[EBP], ECX	;Increase amount transfered
	ADDL	dcb_tcprcvtakp.B[EDI], ECX ;Bump taker data pointer
	SUBL	dcb_tcprcvtakc.B[EDI], ECX ;Reduce amount in this buffer
	SUBL	dcb_tcprcvcnt.B[EDI], ECX ;Reduce total amount available
	ADDL	dcb_tcprcvwinb.B[EDI], ECX ;Open receive window
	JNE	22$.S			;If something left we must be finished
	CALL	tcpget2			;Buffer empty - give up the buffer
	CMPL	tgb_count.B[EBP], #0.B	;Do we want more?
	JE	22$.S			;No - finished
	CMPL	dcb_tcprcvcnt.B[EDI], #0.B ;Yes - have any more data available?
	JNE	4$			;Yes - go get it
22$:	MOVL	ECX, tgb_amount.B[EBP]	;No - get amount transfered
	LEAVE
	RET				;Finished
.PAGE
	.SBTTL	tcprspwait - Subroutine to wait for TCP response

;Subroutine to wait for TCP response - this routine attempts to use a time-out
;  value that is the minimum which will allow 5 or 6 retransmissions if
;  necesary with an absolute minimum value of 20 seconds.  This is hard to do
;  exactly without excessive calculation bacause of the non-linear nature of
;  the retransmission timing scheme.  We use the following formula (times in
;  seconds):
;    RTT  < 1:  TO = RTT * 20
;    RTT >= 1:  TO = 20 + (X - 1) * 5
;	c{EDI} = Offset of DCB
;	CALL	tcprspwait
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

tcprspwait::
	MOVL	EAX, dcb_tcprxmtint[EDI] ;Get the retransmission interval (in
					 ;  ticks)
	CMPL	EAX, #TICKSPERSEC.B	;Less than 1 second?
	JA	4$.S			;No
	IMULL	EAX, #20t*FDPERTICK	;Yes
	JMP	6$.S

;Here if retransmission time is greater than 1 second - use a smaller slope
;  so this time-out does not get to be too large

4$:	ADDL	EAX, #3t*TICKSPERSEC
	IMULL	EAX, #5t*FDPERTICK
6$:	CMPL	EAX, #20t*XT_SECOND
	JA	8$.S
	MOVL	EAX, #20t*XT_SECOND
8$:	JMP	xosnetRspWait##
.PAGE
	.SBTTL	tcpoas - Once-a-second routine

tcpoas::MOVL	ESI, #tcptwdcb#-dcb_tcptwnext ;Get offset of head pointer
4$:	MOVL	EDI, dcb_tcptwnext[ESI]
	TESTL	EDI, EDI		;More to check?
	JE	10$.S			;No
	TOFORK
	DECB	dcb_tcptwcnt[EDI]	;Yes - is this one time out yet?
	JNE	5$.S			;No
	CMPB	dcb_tcpstate.B[EDI], #TCPS_TIMEWAIT ;In timed wait state now?
	JE	6$.S			;Yes
	MOVB	dcb_tcpstate.B[EDI], #TCPS_TIMEWAIT ;No - but it is now
	MOVB	dcb_tcptwcnt[EDI], #TIMECNT_TW
5$:	FROMFORK			;Back to main program level
	MOVL	ESI, EDI		;Advance to next DCB
	JMP	4$.S			;Continue

6$:	MOVL	EAX, dcb_tcptwnext[EDI]	;Remove from list
	MOVL	dcb_tcptwnext[ESI], EAX
	PUSHL	ESI
	CALL	tcpgdcb#		;Give up the DCB
	POPL	ESI
	FROMFORK
	JMP	4$.S

10$:	RET
.PAGE
	DATA

tcpsrcstr:.ASCIZ "DEV^TCP"

.IF NE $$TCPTIME
tcptimepnt:: .LONG tcptimering
tcptimering::.BLKL $$TCPTIME*1024t
tcptimeend:: .LONG 0
tcptimetemp::.LONG 0
.ENDC

xdatatop::

	CODE

xcodetop::

	LKEEND
